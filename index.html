<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aquifer Plumbing Diagram</title>
    <!-- Add KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.js"></script>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* CSS Variables for theming */
        :root { --input-bg-color: #f7fbfe; --input-border-color: #e1f0fa; --input-scrollbar-thumb: #a8d4f0; --input-scrollbar-thumb-hover: #7fc4f0; --calc-bg-color: #faf7fe; --calc-border-color: #e8e1fa; --calc-scrollbar-thumb: #d4a8f0; --calc-scrollbar-thumb-hover: #b27ff0; --calc-inner-bg: #f5f0fc; --inline-input-max-height: 700px; --calculation-max-height: 1200px; --scrollbar-width: 8px; --scrollbar-thumb-radius: 4px; }
        
        /* Global & Body */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: #f0f2f5; color: #333; line-height: 1.6; }

        /* Custom Scrollbar Styling */
        .custom-scroll { scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb) transparent; }
        .custom-scroll::-webkit-scrollbar { width: var(--scrollbar-width); height: var(--scrollbar-width); }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; border-radius: var(--scrollbar-thumb-radius); }
        .custom-scroll::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: var(--scrollbar-thumb-radius); border: none; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
        .custom-scroll-blue { --scrollbar-thumb: var(--input-scrollbar-thumb); --scrollbar-thumb-hover: var(--input-scrollbar-thumb-hover); }
        .custom-scroll-purple { --scrollbar-thumb: var(--calc-scrollbar-thumb); --scrollbar-thumb-hover: var(--calc-scrollbar-thumb-hover); }

        /* Layout & Containers */
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header-container { display: flex; align-items: center; justify-content: center; margin-bottom: 25px; gap: 20px; min-height: 60px; }
        .header-container > div { flex: 1; max-width: 900px; }
        .section { background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px; }
        .input-group { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .input-field { display: flex; flex-direction: column; }
        .constants-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px; }
        .constant-item { display: flex; flex-direction: column; }
        .constant-item.full-width { grid-column: 1 / -1; }
        .form-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; }

        /* Typography */
        h1 { text-align: center; color: #2c3e50; font-size: 2.5em; cursor: pointer; transition: color 0.2s; user-select: none; margin: 0; line-height: 1.2; }
        h1:hover { color: #3498db; }
        .project-subtitle { text-align: center; color: #95a5a6; font-size: 0.9em; font-weight: 400; margin-top: 5px; margin-bottom: 0; padding: 0 40px; max-width: 800px; margin-left: auto; margin-right: auto; line-height: 1.4; transition: all 0.3s ease; cursor: pointer; opacity: 0.85; overflow: hidden; max-height: 100px; }
        .project-subtitle:hover { color: #7f8c8d; opacity: 1; }
        .project-subtitle:empty { max-height: 0; margin-top: 0; padding-top: 0; padding-bottom: 0; opacity: 0; }
        label { font-weight: 500; margin-bottom: 5px; color: #555; }
        .calculation-info h3 { color: #2c3e50; margin-bottom: 15px; }
        .calculation-section h5 { color: #2c3e50; margin-bottom: 10px; font-size: 1.1em; }
        .constant-item label { font-size: 0.9em; margin-bottom: 3px; }
        .custom-times-modal h2 { margin-bottom: 20px; color: #2c3e50; }
        .virgin-pressure-hint { font-size: 0.85em; color: #666; margin-top: 5px; font-style: italic; }

        /* Buttons */
        .project-nav-btn { background: #3498db; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 1.2em; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .project-nav-btn:hover { background: #2980b9; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .project-nav-btn:disabled { background: #95a5a6; cursor: not-allowed; opacity: 0.6; }
        .project-nav-btn:disabled:hover { transform: none; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .constants-btn { position: absolute; bottom: 20px; left: 20px; background: #95a5a6; color: white; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 10px rgba(0,0,0,0.2); transition: all 0.3s ease; }
        .constants-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .info-toggle-btn { position: absolute; bottom: 20px; right: 20px; background: #3498db; color: white; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 10px rgba(0,0,0,0.2); transition: all 0.3s ease; }
        .info-toggle-btn:hover { background: #2980b9; transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        button { background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: 600; transition: background 0.3s ease; }
        button:hover { background: #2980b9; }
        .danger { background: #e74c3c; }
        .danger:hover { background: #c0392b; }
        .secondary { background: #95a5a6; }
        .secondary:hover { background: #7f8c8d; }
        .success { background: #27ae60; }
        .success:hover { background: #229954; }
        .import-export-btn { background: none; color: #666; border: 1px solid #ddd; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 1.1em; transition: all 0.3s ease; }
        .import-export-btn:hover { background: white; color: #333; border-color: #999; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
        .form-actions button { padding: 6px 12px; font-size: 0.9em; min-width: 35px; }
        .icon-btn { background: none; color: #666; border: 1px solid #ddd; }
        .icon-btn:hover { background: white; color: #333; border-color: #999; }
        .icon-btn.primary { background: #3498db; color: white; border-color: #3498db; }
        .icon-btn.primary:hover { background: #2980b9; border-color: #2980b9; }

        /* Forms & Inputs */
        input, select, textarea { padding: 10px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px; transition: border-color 0.3s ease; font-family: inherit; }
        textarea { resize: vertical; min-height: 60px; }
        input:focus, select:focus, textarea:focus { outline: none; border-color: #3498db; }
        input:disabled { background-color: #e8f4fc; cursor: not-allowed; }
        .constant-item input { padding: 8px; }
        .slider-container input { border: none; }
        .project-form input[type="text"], .project-form textarea { width: 100%; margin-bottom: 15px; }
        .import-item-checkbox { width: 20px; height: 20px; cursor: pointer; }
        .import-item-edit input { flex: 1; padding: 4px 8px; font-size: 0.9em; }
        .export-item-checkbox { width: 20px; height: 20px; cursor: pointer; }
        .custom-time-form input[type="text"], .custom-time-form textarea { width: 100%; }
        .time-input-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; }

        /* Inline Input Area - Enhanced */
        .inline-input-container { background: var(--input-bg-color); overflow: hidden; max-height: 0; margin: 0; position: relative; border-radius: 10px; transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), margin 0.3s ease-out, box-shadow 0.3s ease-out, transform 0.3s ease-out; transform: translateY(-10px); opacity: 0; }
        .inline-input-container.active { margin: 20px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border: 1px solid var(--input-border-color); transform: translateY(0); opacity: 1; max-height: var(--inline-input-max-height); }
        .inline-input-content { padding: 20px; position: relative; overflow-y: auto; overflow-x: hidden; max-height: calc(var(--inline-input-max-height) - 40px); }
        .inline-input-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--input-border-color); }
        .inline-input-title { font-size: 1.3em; font-weight: 600; color: #2c3e50; }
        .inline-input-close { background: none; border: none; color: #999; cursor: pointer; font-size: 1.5em; padding: 5px; transition: color 0.2s; line-height: 1; }
        .inline-input-close:hover { color: #333; }

        /* Pressure Table Styles */
        .pressure-table-container { margin: 20px 0; background: rgba(225, 240, 250, 0.3); border-radius: 8px; padding: 15px; border: 1px solid var(--input-border-color); }
        .pressure-table-hint { font-size: 0.85em; color: #666; margin-bottom: 10px; font-style: italic; }
        .pressure-table { width: 100%; border-collapse: collapse; background: white; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .pressure-table th { background: #d9ecfa; padding: 10px; text-align: left; font-weight: 600; color: #495057; font-size: 0.9em; }
        .pressure-table td { padding: 8px; border-top: 1px solid #dee2e6; }
        .pressure-table tr:hover { background: #fafcfe; }
        .pressure-table input { width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; }
        .pressure-table input:focus { border-color: #7fc4f0; background: #fafcfe; }
        .pressure-table .delete-btn { background: none; border: none; color: #e74c3c; cursor: pointer; padding: 4px 8px; border-radius: 4px; transition: all 0.2s; }
        .pressure-table .delete-btn:hover { background: #fee; }
        .add-row-btn { background: #3498db; color: white; padding: 8px 16px; border-radius: 5px; font-size: 0.9em; margin-top: 10px; display: inline-flex; align-items: center; gap: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .add-row-btn:hover { background: #2980b9; }
        .add-row-btn i { font-size: 0.85em; }
        .pressure-table tbody tr:first-child .delete-btn { visibility: hidden; }

        /* Diagram Specific */
        .plumbing-diagram { width: 100%; height: 400px; margin: 20px 0; background: #ffffff; border: 1px solid #e1e4e8; border-radius: 10px; padding: 20px; position: relative; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.06); }
        .time-display { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); font-size: 1.2em; font-weight: 600; color: #2c3e50; }
        .station-wrapper { position: absolute; width: 120px; cursor: pointer; z-index: 10; }
        .station-name { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; font-weight: 700; font-size: 0.95em; white-space: nowrap; text-shadow: 0 2px 4px rgba(0,0,0,0.1), 0 1px 2px rgba(0,0,0,0.1); z-index: 11; }
        .station { width: 100%; height: 85px; border-radius: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; box-shadow: 0 3px 12px rgba(0,0,0,0.15); transition: all 0.3s ease; position: relative; overflow: hidden; }
        .station::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%); pointer-events: none; }
        .station-wrapper:hover .station { transform: translateY(-3px); box-shadow: 0 5px 20px rgba(0,0,0,0.25); }
        .pipe { position: absolute; height: 4px; background: #7f8c8d; top: 50%; transform: translateY(-50%); }
        .parameter-label { position: absolute; font-size: 0.85em; font-weight: 600; color: #2c3e50; cursor: default; }
        .parameter-label.permeability { top: calc(50% - 25px); }
        .parameter-label.dimensions { top: calc(50% + 10px); }
        .distance-label { position: absolute; top: 60px; font-size: 0.9em; font-weight: 600; color: #34495e; }
        .pressure-display { font-size: 0.75em; margin-top: 2px; opacity: 0.9; font-weight: 500; }
        .depletion-display { font-size: 1.1em; margin-top: 4px; font-weight: 800; color: #ffffff; text-shadow: 0 1px 3px rgba(0,0,0,0.3); background: rgba(0,0,0,0.2); padding: 3px 10px; border-radius: 4px; display: inline-block; }

        /* Calculation Info & Display - Enhanced */
        .calculation-info { background: var(--calc-bg-color); border: 1px solid var(--calc-border-color); border-radius: 10px; padding: 0; margin-top: 20px; max-height: 0; overflow: hidden; opacity: 0; transform: translateY(-10px); transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-out; }
        .calculation-info.active { max-height: var(--calculation-max-height); opacity: 1; transform: translateY(0); box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .calculation-info-content { padding: 20px; overflow-y: auto; overflow-x: hidden; max-height: calc(var(--calculation-max-height) - 40px); }
        .calculation-details { background: var(--calc-inner-bg); padding: 15px; border-radius: 6px; margin-top: 10px; border: 1px solid var(--calc-border-color); transition: opacity 0.15s ease; min-height: 200px; position: relative; }
        .equation { font-family: 'Courier New', monospace; background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 4px; margin: 10px 0; overflow-x: auto; border: 1px solid var(--calc-border-color); }
        .katex-display { margin: 10px 0; overflow-x: auto; overflow-y: hidden; }
        .calculation-section { background: rgba(255, 255, 255, 0.7); border: 1px solid var(--calc-border-color); border-radius: 6px; padding: 15px; margin: 15px 0; }
        .calc-value { background: rgba(255, 255, 255, 0.9); padding: 8px 12px; border-radius: 4px; margin: 5px 0; font-family: 'Courier New', monospace; border: 1px solid var(--calc-border-color); }

        /* Time Slider & Dropdown */
        .time-slider { margin: 20px 0; position: relative; }
        .time-slider-header { cursor: pointer; display: inline-block; padding: 5px 10px; border-radius: 5px; transition: background-color 0.2s; position: relative; user-select: none; }
        .time-slider-header:hover { background-color: #f0f2f5; }
        .time-slider-header .dropdown-arrow { font-size: 0.8em; margin-left: 5px; transition: transform 0.2s; }
        .time-slider-header.active .dropdown-arrow { transform: rotate(180deg); }
        .time-dropdown { position: absolute; top: 100%; left: 0; background: white; border: 1px solid #e0e0e0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 100; min-width: 250px; max-height: 300px; overflow-y: auto; display: none; margin-top: 5px; }
        .time-dropdown.active { display: block; }
        .time-dropdown-header { padding: 10px 15px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; font-weight: 600; color: #555; }
        .time-dropdown-gear { cursor: pointer; color: #999; transition: color 0.2s; font-size: 1.1em; }
        .time-dropdown-gear:hover { color: #555; }
        .time-dropdown-item { padding: 10px 15px; cursor: pointer; transition: background-color 0.2s; border-bottom: 1px solid #f0f0f0; }
        .time-dropdown-item:last-child { border-bottom: none; }
        .time-dropdown-item:hover { background-color: #f8f9fa; }
        .time-dropdown-item.selected { background-color: #e3f2fd; font-weight: 600; }
        .time-dropdown-section { padding: 8px 15px; font-size: 0.85em; color: #888; font-weight: 600; background-color: #f8f9fa; border-bottom: 1px solid #e0e0e0; }
        .time-dropdown-empty { padding: 20px; text-align: center; color: #999; font-style: italic; }

        /* Custom Slider Styling */
        .slider-container { position: relative; width: 100%; height: 24px; padding: 10px 0; }
        .slider { -webkit-appearance: none; appearance: none; width: 100%; height: 24px; background: transparent; outline: none; position: absolute; top: 0; left: 0; margin: 0; z-index: 3; cursor: pointer; }
        .slider:focus { outline: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 24px; height: 24px; border-radius: 50%; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 1px solid #ddd; cursor: pointer; position: relative; z-index: 3; margin-top: -10px; }
        .slider::-webkit-slider-runnable-track { width: 100%; height: 4px; background: transparent; border-radius: 2px; }
        .slider::-moz-range-thumb { width: 24px; height: 24px; border-radius: 50%; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 1px solid #ddd; cursor: pointer; border: none; }
        .slider::-moz-range-track { width: 100%; height: 4px; background: transparent; border-radius: 2px; }
        .slider-track-bg { position: absolute; top: 10px; height: 4px; background: #e0e0e0; width: 100%; border-radius: 2px; z-index: 1; }
        .slider-track-fill { position: absolute; top: 10px; height: 4px; background: #7f8c8d; border-radius: 2px; z-index: 2; pointer-events: none; }
        
        /* Modals */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: white; margin: 5% auto; padding: 20px; border-radius: 10px; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 5px 20px rgba(0,0,0,0.3); animation: slideIn 0.3s ease; position: relative; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: #000; }
        .modal-footer { position: absolute; bottom: 20px; left: 20px; display: flex; gap: 10px; }

        /* Project Management */
        .project-list { margin-bottom: 30px; max-height: 300px; overflow-y: auto; }
        .project-item { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px 15px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: start; position: relative; transition: all 0.2s ease; cursor: pointer; }
        .project-item:hover { background: #f0f2f5; }
        .project-item.active { background: #e3f2fd; border-color: #3498db; }
        .project-info { flex: 1; }
        .project-title { font-weight: 600; margin-bottom: 3px; }
        .project-description { font-size: 0.85em; color: #666; margin-bottom: 3px; font-style: italic; }
        .project-date { font-size: 0.85em; color: #666; }
        .project-actions { display: flex; gap: 8px; opacity: 0; transition: opacity 0.2s; }
        .project-item:hover .project-actions { opacity: 1; }
        .project-actions button { padding: 5px 8px; font-size: 0.85em; background: none; border: 1px solid #ddd; color: #666; border-radius: 4px; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; }
        .project-actions button:hover { background: white; color: #333; border-color: #999; }
        .project-actions button.danger:hover { background: #fee; color: #e74c3c; border-color: #e74c3c; }
        .project-form { border-top: 1px solid #e0e0e0; padding-top: 20px; }
        .duplicate-indicator { background: #e3f2fd; border: 1px solid #3498db; border-radius: 6px; padding: 10px; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; color: #2c3e50; }
        .duplicate-indicator i { color: #3498db; font-size: 1.2em; }

        /* Import/Export */
        .import-list { margin-bottom: 20px; max-height: 400px; overflow-y: auto; }
        .import-item { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px 15px; margin-bottom: 8px; display: flex; align-items: center; gap: 15px; transition: all 0.2s ease; }
        .import-item.conflict { background: #fee; border-color: #e74c3c; }
        .import-item-info { flex: 1; }
        .import-item-title { font-weight: 600; margin-bottom: 3px; display: flex; align-items: center; gap: 10px; }
        .import-item-edit { display: none; align-items: center; gap: 8px; }
        .import-item-edit button { padding: 4px 8px; font-size: 0.8em; min-width: 30px; }
        .import-item.editing .import-item-title { display: none; }
        .import-item.editing .import-item-edit { display: flex; }
        .conflict-indicator { color: #e74c3c; font-size: 0.85em; font-style: italic; }
        .import-item-actions { display: flex; gap: 8px; }
        .import-item-actions button { padding: 5px 8px; font-size: 0.85em; background: none; border: 1px solid #ddd; color: #666; border-radius: 4px; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; }
        .import-item-actions button:hover { background: white; color: #333; border-color: #999; }
        .export-list { margin-bottom: 20px; max-height: 400px; overflow-y: auto; }
        .export-item { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px 15px; margin-bottom: 8px; display: flex; align-items: center; gap: 15px; transition: all 0.2s ease; cursor: pointer; }
        .export-item:hover { background: #f0f2f5; }
        .export-item.selected { background: #e3f2fd; border-color: #3498db; }
        .export-select-all { margin-bottom: 15px; display: flex; align-items: center; gap: 10px; padding: 10px; background: #f0f2f5; border-radius: 6px; }

        /* Custom Time Modal */
        .custom-time-list { margin-bottom: 30px; max-height: 200px; overflow-y: auto; }
        .custom-time-item { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px 15px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: start; position: relative; transition: all 0.2s ease; }
        .custom-time-item:hover { background: #f0f2f5; }
        .custom-time-info { flex: 1; }
        .custom-time-title { font-weight: 600; margin-bottom: 3px; }
        .custom-time-description { font-size: 0.85em; color: #666; margin-bottom: 3px; }
        .custom-time-value { font-size: 0.85em; color: #888; }
        .custom-time-actions { display: flex; gap: 8px; opacity: 0; transition: opacity 0.2s; }
        .custom-time-item:hover .custom-time-actions { opacity: 1; }
        .custom-time-actions button { padding: 5px 8px; font-size: 0.85em; background: none; border: 1px solid #ddd; color: #666; border-radius: 4px; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; }
        .custom-time-actions button:hover { background: white; color: #333; border-color: #999; }
        .custom-time-actions button.danger:hover { background: #fee; color: #e74c3c; border-color: #e74c3c; }
        .custom-time-form { border-top: 1px solid #e0e0e0; padding-top: 20px; }

        /* Toggles & Switches */
        .interpolation-toggle { margin: 15px 0; display: flex; align-items: center; gap: 15px; }
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .toggle-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .toggle-slider { background-color: #3498db; }
        input:checked + .toggle-slider:before { transform: translateX(26px); }

        /* Charts */
        .chart-container { position: relative; height: 400px; margin-top: 20px; background: white; border-radius: 8px; padding: 15px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        
        /* Chart Toggle */
        .chart-toggle { display: flex; align-items: center; gap: 10px; margin-top: 10px; padding: 10px 15px; background: #f8f9fa; border-radius: 6px; font-size: 0.9em; }
        .chart-toggle label { margin: 0; font-weight: normal; color: #555; }
        .chart-toggle .toggle-switch { margin: 0 10px; }

        /* Tooltips */
        .tooltip { position: absolute; background: rgba(51, 51, 51, 0.85); color: white; padding: 8px 12px; border-radius: 6px; font-size: 0.9em; white-space: nowrap; z-index: 1000; pointer-events: none; opacity: 0; transition: opacity 0.2s ease-in-out; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transform: translateX(-50%); }
        .tooltip.active { opacity: 1; }
        .tooltip::after { content: ''; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 6px solid rgba(51, 51, 51, 0.85); }

        /* UI States & Debugging */
        .selected-element { outline: 3px solid #3498db; outline-offset: 2px; }
        .debug-info { background: var(--calc-inner-bg); padding: 15px; border-radius: 6px; margin: 15px 0; font-size: 0.95em; border: 1px solid var(--calc-border-color); }
        .debug-info .updating-indicator { color: #999; font-size: 0.9em; font-style: italic; margin-left: 10px; animation: fadeIn 0.3s ease; }

        /* Notifications */
        .notification-container { position: fixed; top: 20px; right: 20px; z-index: 2000; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .notification { background: white; border-radius: 8px; padding: 16px 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 12px; min-width: 300px; max-width: 400px; pointer-events: auto; position: relative; overflow: hidden; animation: slideInRight 0.3s ease-out; }
        .notification.success { border-left: 4px solid #27ae60; }
        .notification.error { border-left: 4px solid #e74c3c; }
        .notification.info { border-left: 4px solid #3498db; }
        .notification.warning { border-left: 4px solid #f39c12; }
        .notification-icon { font-size: 1.2em; flex-shrink: 0; }
        .notification.success .notification-icon { color: #27ae60; }
        .notification.error .notification-icon { color: #e74c3c; }
        .notification.info .notification-icon { color: #3498db; }
        .notification.warning .notification-icon { color: #f39c12; }
        .notification-content { flex: 1; }
        .notification-title { font-weight: 600; margin-bottom: 2px; color: #2c3e50; }
        .notification-message { font-size: 0.9em; color: #555; }
        .notification-close { position: absolute; top: 8px; right: 8px; background: none; border: none; color: #999; cursor: pointer; font-size: 1.2em; padding: 4px; transition: color 0.2s; }
        .notification-close:hover { color: #333; }
        .notification-progress { position: absolute; bottom: 0; left: 0; height: 3px; background: rgba(0,0,0,0.1); border-radius: 0 0 8px 8px; overflow: hidden; }
        .notification-progress-bar { height: 100%; background: currentColor; animation: progressBar var(--duration) linear; transform-origin: left; }
        .notification.success .notification-progress-bar { background: #27ae60; }
        .notification.error .notification-progress-bar { background: #e74c3c; }
        .notification.info .notification-progress-bar { background: #3498db; }
        .notification.warning .notification-progress-bar { background: #f39c12; }
        .notification.hiding { animation: slideOutRight 0.3s ease-in; }

        /* Animations */
        @keyframes slideDown { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideIn { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideOutRight { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        @keyframes progressBar { from { transform: scaleX(1); } to { transform: scaleX(0); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-container">
            <button class="project-nav-btn" id="prevProjectBtn" onclick="appState.navigateProject(-1)" title="Previous Project">
                <i class="fas fa-chevron-left"></i>
            </button>
            <div style="flex: 1;">
                <h1 id="appHeader" onclick="showProjectModal()" title="Click to manage projects">Aquifer Pressure Propagation Simulator</h1>
                <div id="projectSubtitle" class="project-subtitle" onclick="showProjectModal()" title="Click to manage projects"></div>
            </div>
            <button class="project-nav-btn" id="nextProjectBtn" onclick="appState.navigateProject(1)" title="Next Project">
                <i class="fas fa-chevron-right"></i>
            </button>
        </div>

        <!-- Aquifer Display Section -->
        <div class="section">
            <h2>Aquifer Plumbing Diagram</h2>
            
            <!-- Plumbing Diagram -->
            <div class="plumbing-diagram" id="plumbingDiagram">
                <div class="time-display" id="timeDisplay">0.0 years since start</div>
                <div class="constants-btn" onclick="showInlineInput('constants')">Constants</div>
                <div class="info-toggle-btn" onclick="toggleCalculationInfo()">Calculations</div>
            </div>

            <!-- Inline Input Container -->
            <div class="inline-input-container" id="inlineInputContainer">
                <div class="inline-input-content custom-scroll custom-scroll-blue" id="inlineInputContent">
                    <!-- Content will be dynamically populated here -->
                </div>
            </div>

            <!-- Time Slider -->
            <div class="time-slider">
                <div class="time-slider-header" id="timeSliderHeader" onclick="toggleTimeDropdown()">
                    <span id="timeSliderLabel">Time: <span id="currentTime">0</span> years</span>
                    <i class="fas fa-chevron-down dropdown-arrow"></i>
                </div>
                
                <!-- Time dropdown menu -->
                <div class="time-dropdown" id="timeDropdown">
                    <div class="time-dropdown-header">
                        <span>Select Time</span>
                        <i class="fas fa-gear time-dropdown-gear" onclick="showCustomTimesModal()"></i>
                    </div>
                    <div id="timeDropdownContent">
                        <!-- Dynamic content will be populated here -->
                    </div>
                </div>
                
                <div class="slider-container">
                    <div class="slider-track-bg"></div>
                    <div class="slider-track-fill" id="sliderTrack"></div>
                    <input type="range" id="timeSlider" class="slider" min="0" max="10" step="0.01" value="0">
                </div>
            </div>

            <!-- Calculation Info Area -->
            <div class="calculation-info" id="calculationInfo">
                <div class="calculation-info-content custom-scroll custom-scroll-purple">
                    <h3>Calculation Details</h3>
                    <p>Hover over any station to see its calculation details.</p>
                    
                    <div class="debug-info" id="debugInfo">
                        <!-- Debug info will be shown here -->
                    </div>
                    
                    <div id="calculationDetails" class="calculation-details">
                        <!-- Details will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Pressure Chart -->
            <div class="chart-container">
                <canvas id="stationPressureChart"></canvas>
            </div>
            
            <!-- Chart Toggle -->
            <div class="chart-toggle">
                <label>Depletion</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="chartViewToggle" onchange="toggleChartView()">
                    <span class="toggle-slider"></span>
                </label>
                <label>Absolute Pressure</label>
            </div>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <!-- Notification Container -->
    <div class="notification-container" id="notificationContainer"></div>

    <!-- Modals -->
    <!-- Project Management Modal -->
    <div id="projectModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('projectModal')">&times;</span>
            <h2>Project Management</h2>
            
            <!-- Project list -->
            <div class="project-list" id="projectList">
                <!-- Projects will be listed here -->
            </div>
            
            <!-- Add/Edit form -->
            <div class="project-form">
                <input type="hidden" id="editingProjectIndex" value="-1">
                <input type="hidden" id="isDuplicating" value="false">
                
                <div id="duplicateIndicator" class="duplicate-indicator" style="display: none;">
                    <i class="fas fa-copy"></i>
                    <span>Duplicating project - edit details below</span>
                </div>
                
                <input type="text" id="projectName" placeholder="Project Name">
                <textarea id="projectDescription" placeholder="Description (optional)" rows="2"></textarea>
                
                <div class="form-actions">
                    <button class="secondary" onclick="clearProjectForm()">Cancel</button>
                    <button class="primary" onclick="saveProject()">Save Project</button>
                </div>
            </div>
            
            <div class="modal-footer">
                <button class="import-export-btn" onclick="showImportModal()" title="Import Projects">
                    <i class="fas fa-file-import"></i>
                </button>
                <button class="import-export-btn" onclick="showExportModal()" title="Export Projects">
                    <i class="fas fa-file-export"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('importModal')">&times;</span>
            <h2>Import Projects</h2>
            
            <input type="file" id="importFile" accept=".json" multiple onchange="handleImportFiles()" style="margin-bottom: 20px;">
            
            <div class="import-list" id="importList" style="display: none;">
                <!-- Import items will be listed here -->
            </div>
            
            <div class="form-actions" id="importActions" style="display: none;">
                <button class="secondary" onclick="closeModal('importModal')">Cancel</button>
                <button class="primary" onclick="performImport()">Import Selected</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div id="exportModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('exportModal')">&times;</span>
            <h2>Export Projects</h2>
            
            <div class="export-select-all">
                <input type="checkbox" id="selectAllExport" onchange="toggleSelectAllExport()">
                <label for="selectAllExport">Select All</label>
            </div>
            
            <div class="export-list" id="exportList">
                <!-- Export items will be listed here -->
            </div>
            
            <div class="form-actions">
                <button class="secondary" onclick="closeModal('exportModal')">Cancel</button>
                <button class="primary" onclick="performExport()">Export Selected</button>
            </div>
        </div>
    </div>

    <!-- Custom Times Modal -->
    <div id="customTimesModal" class="modal custom-times-modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('customTimesModal')">&times;</span>
            <h2>Custom Times</h2>
            
            <!-- Existing custom times list -->
            <div class="custom-time-list" id="customTimeList">
                <!-- Custom times will be listed here -->
            </div>
            
            <!-- Add/Edit form -->
            <div class="custom-time-form">
                <input type="hidden" id="editingIndex" value="-1">
                
                <div style="margin-bottom: 15px;">
                    <input type="text" id="customTimeTitle" placeholder="Title (e.g., Start of Production)">
                </div>
                
                <div class="time-input-row">
                    <input type="number" id="customTimeYears" step="0.1" placeholder="Years from start" oninput="onTimeInputChange('years')">
                    <input type="date" id="customTimeDate" oninput="onTimeInputChange('date')">
                </div>
                
                <div style="margin-bottom: 15px;">
                    <textarea id="customTimeDescription" placeholder="Description (optional)" rows="2"></textarea>
                </div>
                
                <div class="form-actions">
                    <button class="icon-btn" onclick="clearCustomTimeForm()" title="Clear">
                        <i class="fas fa-times"></i>
                    </button>
                    <button class="icon-btn primary" onclick="saveCustomTime()" title="Save">
                        <i class="fas fa-check"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script>
        // ===========================================
        // CONFIGURATION
        // ===========================================
        const INLINE_INPUT_MAX_HEIGHT = getComputedStyle(document.documentElement)
            .getPropertyValue('--inline-input-max-height');
        const CALCULATION_MAX_HEIGHT = getComputedStyle(document.documentElement)
            .getPropertyValue('--calculation-max-height');
        
        // ===========================================
        // CENTRAL STATE MANAGER
        // ===========================================
        class AppStateManager {
            constructor() {
                this.state = {
                    projects: [],
                    currentProjectId: null,
                    appSettings: {
                        currentTime: 0,
                        showDepletionChart: true // New setting for chart view
                    }
                };
                
                this.listeners = [];
                this.saveTimeout = null;
                this.saveDelay = 500; // ms
            }
            
            // Initialize from localStorage
            init() {
                const savedData = localStorage.getItem('aquiferSimProjects');
                
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        this.state = {
                            projects: data.projects || [],
                            currentProjectId: data.currentProjectId,
                            appSettings: data.appSettings || { currentTime: 0, showDepletionChart: true }
                        };
                        
                        // Ensure showDepletionChart exists
                        if (this.state.appSettings.showDepletionChart === undefined) {
                            this.state.appSettings.showDepletionChart = true;
                        }
                        
                        // Migrate old data format to new segmentDistance format
                        this.state.projects.forEach(project => {
                            if (project.description === undefined) {
                                project.description = '';
                            }
                            if (project.config.aquiferOverpressure === undefined) {
                                project.config.aquiferOverpressure = 0;
                            }
                            
                            // Migrate station distances to segment distances
                            if (project.config.stations && project.config.stations.length > 0) {
                                const oldStation = project.config.stations[0];
                                if (oldStation.distance !== undefined && oldStation.segmentDistance === undefined) {
                                    // Need to migrate
                                    this.migrateStationDistances(project.config.stations);
                                }
                            }
                        });
                        
                        // Validate current project exists
                        if (this.state.currentProjectId && !this.getProject(this.state.currentProjectId)) {
                            this.state.currentProjectId = this.state.projects.length > 0 ? 
                                this.state.projects[0].id : null;
                        }
                    } catch (e) {
                        console.error('Error loading state:', e);
                        this.createDefaultProject();
                    }
                } else {
                    // Try to migrate from old format
                    this.migrateOldData();
                }
                
                // Ensure at least one project exists
                if (this.state.projects.length === 0) {
                    this.createDefaultProject();
                }
            }
            
            // Migrate station distances from absolute to segment
            migrateStationDistances(stations) {
                // First sort stations by their old distance values
                const sortedStations = [...stations].sort((a, b) => {
                    // Handle missing distance property
                    const aDist = a.distance !== undefined ? a.distance : 0;
                    const bDist = b.distance !== undefined ? b.distance : 0;
                    
                    if (aDist === 0) return bDist === 0 ? 0 : (b.isLeft ? 1 : -1);
                    if (bDist === 0) return a.isLeft ? -1 : 1;
                    if (a.isLeft && b.isLeft) return bDist - aDist;
                    if (!a.isLeft && !b.isLeft) return aDist - bDist;
                    return a.isLeft ? -1 : 1;
                });
                
                // Calculate segment distances
                for (let i = 0; i < sortedStations.length; i++) {
                    const station = sortedStations[i];
                    
                    if (i === 0) {
                        // First station in sorted order (leftmost)
                        station.segmentDistance = station.distance !== undefined ? station.distance : 10;
                    } else {
                        const prevStation = sortedStations[i - 1];
                        const prevDist = prevStation.distance !== undefined ? prevStation.distance : 0;
                        const currDist = station.distance !== undefined ? station.distance : prevDist + 10;
                        station.segmentDistance = Math.abs(currDist - prevDist);
                    }
                    
                    // Remove old distance property
                    delete station.distance;
                }
            }
            
            // Migrate from old localStorage format
            migrateOldData() {
                const oldConfig = localStorage.getItem('aquiferSimConfig');
                if (oldConfig) {
                    try {
                        const config = JSON.parse(oldConfig);
                        const project = this.createDefaultProjectConfig();
                        project.id = this.generateProjectId();
                        project.name = config.customHeader || 'Migrated Project';
                        project.description = '';
                        project.created = Date.now();
                        project.modified = Date.now();
                        project.config = config;
                        
                        // Remove old fields
                        delete project.config.customHeader;
                        delete project.config.currentTime;
                        
                        // Add new fields if missing
                        if (project.config.aquiferOverpressure === undefined) {
                            project.config.aquiferOverpressure = 0;
                        }
                        
                        // Migrate station distances
                        if (project.config.stations && project.config.stations.length > 0) {
                            this.migrateStationDistances(project.config.stations);
                        }
                        
                        this.state.projects = [project];
                        this.state.currentProjectId = project.id;
                        this.state.appSettings.currentTime = config.currentTime || 0;
                        
                        this.saveToStorage();
                        localStorage.removeItem('aquiferSimConfig');
                    } catch (e) {
                        console.error('Error migrating old config:', e);
                        this.createDefaultProject();
                    }
                } else {
                    this.createDefaultProject();
                }
            }
            
            // Generate unique project ID
            generateProjectId() {
                return 'project_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
            
            // Create default project configuration
            createDefaultProjectConfig() {
                return {
                    id: this.generateProjectId(),
                    name: 'New Project',
                    description: '',
                    created: Date.now(),
                    modified: Date.now(),
                    config: {
                        stations: [],
                        numStations: 2,
                        numStationsLeft: 0,
                        pressureData: [],
                        offtakeDepth: 2000,
                        useSplineInterpolation: true,
                        simulationLength: 10,
                        startDate: '',
                        waterDensity: 1.04,
                        waterViscosity: 0.4,
                        waterCompressibility: 4.5e-5,
                        rockCompressibility: 1e-5,
                        reservoirTemp: 80,
                        aquiferOverpressure: 0,
                        customTimes: [],
                        selectedCustomTime: null
                    }
                };
            }
            
            // Create and add default project
            createDefaultProject() {
                const project = this.createDefaultProjectConfig();
                this.state.projects = [project];
                this.state.currentProjectId = project.id;
                this.queueSave();
            }
            
            // Subscribe to state changes
            subscribe(listener) {
                this.listeners.push(listener);
                return () => {
                    this.listeners = this.listeners.filter(l => l !== listener);
                };
            }
            
            // Notify all listeners
            notify(changeType, data) {
                this.listeners.forEach(listener => listener(changeType, data));
            }
            
            // Queue save with debouncing
            queueSave() {
                if (this.saveTimeout) {
                    clearTimeout(this.saveTimeout);
                }
                this.saveTimeout = setTimeout(() => this.saveToStorage(), this.saveDelay);
            }
            
            // Save to localStorage
            saveToStorage() {
                try {
                    const storageData = {
                        projects: this.state.projects,
                        currentProjectId: this.state.currentProjectId,
                        appSettings: this.state.appSettings
                    };
                    localStorage.setItem('aquiferSimProjects', JSON.stringify(storageData));
                } catch (e) {
                    console.error('Error saving to localStorage:', e);
                    showNotification(
                        'Failed to save data. Storage may be full.',
                        'error',
                        5000,
                        'Storage Error'
                    );
                }
            }
            
            // Get current project
            getCurrentProject() {
                return this.getProject(this.state.currentProjectId);
            }
            
            // Get project by ID
            getProject(projectId) {
                return this.state.projects.find(p => p.id === projectId);
            }
            
            // Get all projects
            getProjects() {
                return this.state.projects;
            }
            
            // Get app settings
            getAppSettings() {
                return this.state.appSettings;
            }
            
            // Create new project
            createProject(name, description) {
                const project = this.createDefaultProjectConfig();
                project.name = name;
                project.description = description;
                
                this.state.projects.push(project);
                this.queueSave();
                this.notify('projectCreated', project);
                
                return project;
            }
            
            // Update project metadata
            updateProject(projectId, updates) {
                const project = this.getProject(projectId);
                if (!project) return;
                
                Object.assign(project, updates);
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('projectUpdated', project);
            }
            
            // Delete project
            deleteProject(projectId) {
                const index = this.state.projects.findIndex(p => p.id === projectId);
                if (index === -1) return;
                
                this.state.projects.splice(index, 1);
                
                // If deleted current project, switch to first available
                if (projectId === this.state.currentProjectId) {
                    this.state.currentProjectId = this.state.projects.length > 0 ? 
                        this.state.projects[0].id : null;
                }
                
                this.queueSave();
                this.notify('projectDeleted', projectId);
            }
            
            // Duplicate project
            duplicateProject(projectId) {
                const original = this.getProject(projectId);
                if (!original) return null;
                
                const duplicate = JSON.parse(JSON.stringify(original));
                duplicate.id = this.generateProjectId();
                duplicate.name = original.name + ' (Copy)';
                duplicate.created = Date.now();
                duplicate.modified = Date.now();
                
                this.state.projects.push(duplicate);
                this.queueSave();
                this.notify('projectCreated', duplicate);
                
                return duplicate;
            }
            
            // Switch to project
            switchProject(projectId) {
                const project = this.getProject(projectId);
                if (!project) return;
                
                this.state.currentProjectId = projectId;
                this.queueSave();
                this.notify('projectSwitched', project);
            }
            
            // Navigate projects
            navigateProject(direction) {
                const currentIndex = this.state.projects.findIndex(p => 
                    p.id === this.state.currentProjectId);
                const newIndex = currentIndex + direction;
                
                if (newIndex >= 0 && newIndex < this.state.projects.length) {
                    this.switchProject(this.state.projects[newIndex].id);
                }
            }
            
            // Update current time
            updateCurrentTime(time) {
                this.state.appSettings.currentTime = time;
                this.queueSave();
                this.notify('currentTimeChanged', time);
            }
            
            // Update chart view preference
            updateChartView(showDepletion) {
                this.state.appSettings.showDepletionChart = showDepletion;
                this.queueSave();
                this.notify('chartViewChanged', showDepletion);
            }
            
            // Update station
            updateStation(stationIndex, updates) {
                const project = this.getCurrentProject();
                if (!project || !project.config.stations[stationIndex]) return;
                
                Object.assign(project.config.stations[stationIndex], updates);
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('stationUpdated', { stationIndex, updates });
            }
            
            // Update all stations
            updateStations(stations) {
                const project = this.getCurrentProject();
                if (!project) return;
                
                project.config.stations = stations;
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('stationsUpdated', stations);
            }
            
            // Update number of stations
            updateNumStations(num) {
                const project = this.getCurrentProject();
                if (!project) return;
                
                project.config.numStations = num;
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('numStationsUpdated', num);
            }
            
            // Update number of stations left
            updateNumStationsLeft(num) {
                const project = this.getCurrentProject();
                if (!project) return;
                
                project.config.numStationsLeft = num;
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('numStationsLeftUpdated', num);
            }
            
            // Update pressure data
            updatePressureData(pressureData) {
                const project = this.getCurrentProject();
                if (!project) return;
                
                project.config.pressureData = pressureData;
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('pressureDataUpdated', pressureData);
            }
            
            // Update offtake settings
            updateOfftakeSettings(settings) {
                const project = this.getCurrentProject();
                if (!project) return;
                
                Object.assign(project.config, settings);
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('offtakeSettingsUpdated', settings);
            }
            
            // Update constants
            updateConstants(constants) {
                const project = this.getCurrentProject();
                if (!project) return;
                
                Object.assign(project.config, constants);
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('constantsUpdated', constants);
            }
            
            // Update custom times
            updateCustomTimes(customTimes) {
                const project = this.getCurrentProject();
                if (!project) return;
                
                project.config.customTimes = customTimes;
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('customTimesUpdated', customTimes);
            }
            
            // Update selected custom time
            updateSelectedCustomTime(index) {
                const project = this.getCurrentProject();
                if (!project) return;
                
                project.config.selectedCustomTime = index;
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('selectedCustomTimeUpdated', index);
            }
            
            // Update custom times and selected time together
            updateCustomTimesAndSelection(customTimes, selectedIndex) {
                const project = this.getCurrentProject();
                if (!project) return;
                
                project.config.customTimes = customTimes;
                project.config.selectedCustomTime = selectedIndex;
                project.modified = Date.now();
                
                this.queueSave();
                this.notify('customTimesUpdated', customTimes);
            }
            
            // Import projects
            importProjects(projectsToImport, overwriteExisting = true) {
                const imported = [];
                
                projectsToImport.forEach(importProject => {
                    const existingIndex = this.state.projects.findIndex(p => 
                        p.name.toLowerCase() === importProject.name.toLowerCase()
                    );
                    
                    if (existingIndex !== -1 && overwriteExisting) {
                        // Overwrite existing
                        this.state.projects[existingIndex] = {
                            ...importProject,
                            id: this.state.projects[existingIndex].id,
                            modified: Date.now()
                        };
                        imported.push(this.state.projects[existingIndex]);
                    } else if (existingIndex === -1) {
                        // Add new
                        const newProject = {
                            ...importProject,
                            id: this.generateProjectId(),
                            created: Date.now(),
                            modified: Date.now()
                        };
                        this.state.projects.push(newProject);
                        imported.push(newProject);
                    }
                });
                
                this.queueSave();
                this.notify('projectsImported', imported);
                
                return imported;
            }
            
            // Export projects
            exportProjects(projectIds) {
                return this.state.projects.filter(p => projectIds.includes(p.id))
                    .map(p => ({ ...p, exported: Date.now() }));
            }
        }
        
        // Create global state manager instance
        const appState = new AppStateManager();
        
        // ===========================================
        // GLOBAL VARIABLES (NOW DERIVED FROM STATE)
        // ===========================================
        let pressureChart = null;
        let stationPressureChart = null;
        let currentStationIndex = null;
        let selectedElement = null;
        let lastCalculationDetails = {};
        let lastHoveredStation = 0;
        let initialPressures = [];
        let timeLinePlugin = null;
        let importProjects = [];
        let selectedExportProjects = new Set();
        let currentInlineInputType = null;
        let currentInlineInputData = null;
        
        // Debounce timer for calculation updates
        let calculationUpdateTimeout = null;
        const CALCULATION_UPDATE_DELAY = 150; // ms
        
        // Station colors
        const stationColors = [
            '#e74c3c', // Red - Offtake
            '#f39c12', // Orange
            '#27ae60', // Green
            '#3498db', // Blue
            '#9b59b6', // Purple
            '#e67e22', // Dark Orange
            '#16a085', // Teal
            '#34495e', // Dark Gray
            '#c0392b', // Dark Red
            '#8e44ad'  // Dark Purple
        ];
        
        // Create time line plugin for Chart.js
        const verticalLinePlugin = {
            id: 'verticalLine',
            afterDraw: (chart, args, options) => {
                if (options.x !== undefined && options.x !== null) {
                    const ctx = chart.ctx;
                    const xAxis = chart.scales.x;
                    const yAxis = chart.scales.y;
                    const x = xAxis.getPixelForValue(options.x);
                    
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(x, yAxis.top);
                    ctx.lineTo(x, yAxis.bottom);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.stroke();
                    ctx.restore();
                }
            }
        };
        
        // Background color plugin for Chart.js
        const customCanvasBackgroundColor = {
            id: 'customCanvasBackgroundColor',
            beforeDraw: (chart, args, options) => {
                const {ctx} = chart;
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = options.color || '#ffffff';
                ctx.fillRect(0, 0, chart.width, chart.height);
                ctx.restore();
            }
        };
        
        // Register the plugins
        Chart.register(verticalLinePlugin, customCanvasBackgroundColor);
        
        // ===========================================
        // NOTIFICATION SYSTEM
        // ===========================================
        
        function showNotification(message, type = 'info', duration = 5000, title = '') {
            const container = document.getElementById('notificationContainer');
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.style.setProperty('--duration', duration + 'ms');
            
            // Set icon based on type
            let icon = '';
            switch (type) {
                case 'success':
                    icon = '<i class="fas fa-check-circle"></i>';
                    if (!title) title = 'Success';
                    break;
                case 'error':
                    icon = '<i class="fas fa-exclamation-circle"></i>';
                    if (!title) title = 'Error';
                    break;
                case 'warning':
                    icon = '<i class="fas fa-exclamation-triangle"></i>';
                    if (!title) title = 'Warning';
                    break;
                case 'info':
                default:
                    icon = '<i class="fas fa-info-circle"></i>';
                    if (!title) title = 'Info';
                    break;
            }
            
            // Build notification HTML
            notification.innerHTML = `
                <div class="notification-icon">${icon}</div>
                <div class="notification-content">
                    <div class="notification-title">${title}</div>
                    <div class="notification-message">${message}</div>
                </div>
                <button class="notification-close" onclick="dismissNotification(this)">
                    <i class="fas fa-times"></i>
                </button>
                <div class="notification-progress">
                    <div class="notification-progress-bar"></div>
                </div>
            `;
            
            // Add to container
            container.appendChild(notification);
            
            // Auto-dismiss after duration
            const timeoutId = setTimeout(() => {
                dismissNotification(notification);
            }, duration);
            
            // Store timeout ID for manual dismissal
            notification.dataset.timeoutId = timeoutId;
            
            return notification;
        }
        
        function dismissNotification(element) {
            // Get the notification element (could be the button or the notification itself)
            const notification = element.classList.contains('notification') ? 
                element : element.closest('.notification');
            
            if (!notification) return;
            
            // Clear the auto-dismiss timeout
            if (notification.dataset.timeoutId) {
                clearTimeout(parseInt(notification.dataset.timeoutId));
            }
            
            // Add hiding animation
            notification.classList.add('hiding');
            
            // Remove after animation completes
            setTimeout(() => {
                notification.remove();
            }, 300);
        }
        
        // ===========================================
        // STATE CHANGE LISTENERS
        // ===========================================
        
        // Subscribe to state changes
        appState.subscribe((changeType, data) => {
            switch (changeType) {
                case 'projectSwitched':
                    loadProjectToUI(data);
                    break;
                case 'projectsImported':
                case 'projectCreated':
                case 'projectUpdated':
                case 'projectDeleted':
                    updateProjectList();
                    updateProjectNavigation();
                    updateHeader();
                    break;
                case 'stationUpdated':
                    // Update chart label when station is updated
                    const project = appState.getCurrentProject();
                    if (stationPressureChart && project && project.config.stations && 
                        data.stationIndex < project.config.stations.length &&
                        stationPressureChart.data.datasets[data.stationIndex]) {
                        const station = project.config.stations[data.stationIndex];
                        stationPressureChart.data.datasets[data.stationIndex].label = station.name;
                        stationPressureChart.update();
                    }
                    renderStations();
                    updatePressureHistory(); // Add this to recalculate pressure history
                    updateSimulation();
                    break;
                case 'stationsUpdated':
                case 'numStationsUpdated':
                case 'numStationsLeftUpdated':
                    renderStations();
                    updateSimulation();
                    break;
                case 'pressureDataUpdated':
                    updatePressureChart();
                    updatePressureHistory(); // Add this line - this was missing!
                    updateSimulation();
                    break;
                case 'constantsUpdated':
                    // Update virgin pressure display if inline input is open
                    if (currentInlineInputType) {
                        updateOfftakeVirginPressure();
                        updateStationVirginPressure();
                    }
                    updatePressureHistory();
                    updateSimulation();
                    break;
                case 'offtakeSettingsUpdated':
                    updatePressureChart();
                    loadPressureTable(); // Reload pressure table to update initial pressure
                    updatePressureHistory();
                    updateSimulation();
                    break;
                case 'customTimesUpdated':
                    updateTimeSliderLabel();
                    break;
                case 'selectedCustomTimeUpdated':
                    // Don't call updateTimeSliderLabel here to avoid circular dependency
                    // The label is already updated by the time slider handler
                    break;
                case 'currentTimeChanged':
                    // Time slider already handles its own updates
                    break;
                case 'chartViewChanged':
                    updatePressureHistory();
                    break;
            }
        });
        
        // ===========================================
        // INLINE INPUT FUNCTIONS
        // ===========================================
        
        function showInlineInput(type, data = null) {
            const container = document.getElementById('inlineInputContainer');
            const content = document.getElementById('inlineInputContent');
            
            // If showing the same type that's already open, close it
            if (currentInlineInputType === type && 
                type !== 'station' || 
                (type === 'station' && currentInlineInputData === data)) {
                closeInlineInput();
                return;
            }
            
            // Store current type and data
            currentInlineInputType = type;
            currentInlineInputData = data;
            
            // Clear existing content
            content.innerHTML = '';
            
            // Create content based on type
            let html = '';
            
            if (type === 'constants') {
                html = createConstantsInputContent();
            } else if (type === 'offtake') {
                html = createOfftakeInputContent();
            } else if (type === 'station' && data !== null) {
                html = createStationInputContent(data);
            }
            
            content.innerHTML = html;
            
            // Add active class to trigger animation
            container.classList.add('active');
            
            // Initialize event listeners for the new content
            if (type === 'offtake') {
                setupOfftakeEventListeners();
                loadPressureTable();
                updateOfftakeVirginPressure();
                // Delay chart initialization to ensure DOM is ready
                setTimeout(() => {
                    updatePressureChart();
                }, 50);
            } else if (type === 'station' && data !== null) {
                setupStationEventListeners();
                updateStationVirginPressure();
            } else if (type === 'constants') {
                setupConstantsEventListeners();
            }
        }
        
        function closeInlineInput() {
            const container = document.getElementById('inlineInputContainer');
            
            // Remove active class to trigger animation
            container.classList.remove('active');
            
            // Clear type and data after transition
            setTimeout(() => {
                currentInlineInputType = null;
                currentInlineInputData = null;
            }, 400);
        }
        
        function createConstantsInputContent() {
            const project = appState.getCurrentProject();
            if (!project) return '';
            
            const config = project.config;
            
            return `
                <div class="inline-input-header">
                    <h3 class="inline-input-title">Physical Constants</h3>
                    <button class="inline-input-close" onclick="closeInlineInput()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="constants-grid">
                    <div class="constant-item">
                        <label>Number of Stations (Right)</label>
                        <input type="number" id="numStations" value="${config.numStations}" min="0" max="10" step="1">
                    </div>
                    <div class="constant-item">
                        <label>Number of Stations (Left)</label>
                        <input type="number" id="numStationsLeft" value="${config.numStationsLeft || 0}" min="0" max="10" step="1">
                    </div>
                    <div class="constant-item">
                        <label>Simulation Length (years)</label>
                        <input type="number" id="simulationLength" value="${config.simulationLength}" min="1" max="100" step="1">
                    </div>
                    <div class="constant-item">
                        <label>Start Date (optional)</label>
                        <input type="date" id="startDate" value="${config.startDate || ''}">
                    </div>
                    <div class="constant-item">
                        <label>Water Density (SG)</label>
                        <input type="number" id="waterDensity" value="${config.waterDensity}" step="0.01">
                    </div>
                    <div class="constant-item">
                        <label>Water Viscosity (cP)</label>
                        <input type="number" id="waterViscosity" value="${config.waterViscosity}" step="0.01">
                    </div>
                    <div class="constant-item">
                        <label>Water Compressibility (1/bar)</label>
                        <input type="number" id="waterCompressibility" value="${config.waterCompressibility}" step="1e-6">
                    </div>
                    <div class="constant-item">
                        <label>Rock Compressibility (1/bar)</label>
                        <input type="number" id="rockCompressibility" value="${config.rockCompressibility}" step="1e-6">
                    </div>
                    <div class="constant-item">
                        <label>Reservoir Temperature (C)</label>
                        <input type="number" id="reservoirTemp" value="${config.reservoirTemp}" step="5">
                    </div>
                    <div class="constant-item">
                        <label>Aquifer Overpressure (bar)</label>
                        <input type="number" id="aquiferOverpressure" value="${config.aquiferOverpressure || 0}" step="1">
                    </div>
                </div>
            `;
        }
        
        function createOfftakeInputContent() {
            const project = appState.getCurrentProject();
            if (!project) return '';
            
            const config = project.config;
            const offtakeStation = config.stations ? config.stations.find(s => s.id === 'offtake') : null;
            const customName = offtakeStation ? offtakeStation.customName || '' : '';
            
            return `
                <div class="inline-input-header">
                    <h3 class="inline-input-title">Offtake Configuration</h3>
                    <button class="inline-input-close" onclick="closeInlineInput()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="input-field" style="margin-bottom: 20px;">
                    <label>Station Name</label>
                    <input type="text" id="offtakeCustomName" placeholder="Default: Offtake" value="${customName}">
                </div>
                <div class="input-field" style="margin-bottom: 20px;">
                    <label>Depth (m tvdss)</label>
                    <input type="number" id="offtakeDepth" value="${config.offtakeDepth}" step="10">
                    <div class="virgin-pressure-hint" id="offtakeVirginPressure">Virgin pressure: -- bar</div>
                </div>
                <h3>Pressure Schedule</h3>
                <div class="pressure-table-container">
                    <div class="pressure-table-hint">
                        <i class="fas fa-info-circle"></i> You can paste data directly from Excel or CSV
                    </div>
                    <table class="pressure-table" id="pressureTable">
                        <thead>
                            <tr>
                                <th>Time (years)</th>
                                <th>Pressure (bar)</th>
                                <th style="width: 50px;"></th>
                            </tr>
                        </thead>
                        <tbody id="pressureTableBody">
                            <!-- Rows will be added here -->
                        </tbody>
                    </table>
                    <button class="add-row-btn" onclick="addPressureRow()">
                        <i class="fas fa-plus"></i> Add Row
                    </button>
                </div>
                <div class="interpolation-toggle">
                    <label>Use Smooth Interpolation:</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="useSplineInterpolation" ${config.useSplineInterpolation ? 'checked' : ''}>
                        <span class="toggle-slider"></span>
                    </label>
                    <span style="color: #666; font-size: 0.9em;">(Cubic spline vs linear)</span>
                </div>
                <div class="chart-container">
                    <canvas id="pressureChart"></canvas>
                </div>
            `;
        }
        
        function createStationInputContent(stationIndex) {
            const project = appState.getCurrentProject();
            if (!project || !project.config.stations) return '';
            
            const station = project.config.stations[stationIndex];
            
            // Find the previous station based on the station's side
            let prevStation = null;
            let prevStationName = 'Offtake';
            
            if (station.isLeft) {
                // For left stations, find the previous station in the ordered list
                const orderedStations = getOrderedStations(project.config.stations);
                const stationPos = orderedStations.findIndex(s => s === station);
                if (stationPos > 0) {
                    prevStation = orderedStations[stationPos - 1];
                    prevStationName = prevStation.name;
                }
            } else {
                // For right stations, find the previous station in the ordered list
                const orderedStations = getOrderedStations(project.config.stations);
                const stationPos = orderedStations.findIndex(s => s === station);
                if (stationPos > 0) {
                    prevStation = orderedStations[stationPos - 1];
                    prevStationName = prevStation.name;
                }
            }
            
            const distanceLabel = `Distance to ${prevStationName} (km)`;
            
            return `
                <div class="inline-input-header">
                    <h3 class="inline-input-title">${station.name} Parameters</h3>
                    <button class="inline-input-close" onclick="closeInlineInput()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="input-group">
                    <div class="input-field">
                        <label>Station Name</label>
                        <input type="text" id="modalCustomName" placeholder="Default: Station X" value="${station.customName || ''}">
                    </div>
                    <div class="input-field">
                        <label>Depth (m tvdss)</label>
                        <input type="number" id="modalDepth" step="10" value="${station.depth}">
                        <div class="virgin-pressure-hint" id="stationVirginPressure">Virgin pressure: -- bar</div>
                    </div>
                    <div class="input-field">
                        <label>${distanceLabel}</label>
                        <input type="number" id="modalDistance" step="1" min="0" value="${station.segmentDistance}">
                    </div>
                    <div class="input-field">
                        <label>Permeability (mD)</label>
                        <input type="number" id="modalPermeability" step="10" min="0" value="${station.permeability}">
                    </div>
                    <div class="input-field">
                        <label>Average Net/Gross</label>
                        <input type="number" id="modalNTG" step="0.01" min="0" max="1" value="${station.ntg}">
                    </div>
                    <div class="input-field">
                        <label>Aquifer Width (km)</label>
                        <input type="number" id="modalWidth" step="0.1" value="${station.width}">
                    </div>
                    <div class="input-field">
                        <label>Aquifer Height (m)</label>
                        <input type="number" id="modalHeight" step="1" value="${station.height}">
                    </div>
                    <div class="input-field">
                        <label>Porosity</label>
                        <input type="number" id="modalPorosity" step="0.01" min="0" max="1" value="${station.porosity}">
                    </div>
                </div>
            `;
        }
        
        function setupConstantsEventListeners() {
            document.getElementById('numStations').addEventListener('input', function() {
                const num = parseInt(this.value);
                appState.updateNumStations(num);
                updateStations();
            });
            
            document.getElementById('numStationsLeft').addEventListener('input', function() {
                const num = parseInt(this.value);
                appState.updateNumStationsLeft(num);
                updateStations();
            });
            
            document.getElementById('simulationLength').addEventListener('input', function() {
                const length = parseFloat(this.value);
                document.getElementById('timeSlider').max = length;
                appState.updateConstants({ simulationLength: length });
                updateSimulation();
            });
            
            document.getElementById('startDate').addEventListener('input', function() {
                appState.updateConstants({ startDate: this.value });
                updateSimulation();
            });
            
            document.getElementById('waterDensity').addEventListener('input', function() {
                appState.updateConstants({ waterDensity: parseFloat(this.value) });
                updateSimulation();
            });
            
            document.getElementById('waterViscosity').addEventListener('input', function() {
                appState.updateConstants({ waterViscosity: parseFloat(this.value) });
                updateSimulation();
            });
            
            document.getElementById('waterCompressibility').addEventListener('input', function() {
                appState.updateConstants({ waterCompressibility: parseFloat(this.value) });
                updateSimulation();
            });
            
            document.getElementById('rockCompressibility').addEventListener('input', function() {
                appState.updateConstants({ rockCompressibility: parseFloat(this.value) });
                updateSimulation();
            });
            
            document.getElementById('reservoirTemp').addEventListener('input', function() {
                appState.updateConstants({ reservoirTemp: parseFloat(this.value) });
                updateSimulation();
            });
            
            document.getElementById('aquiferOverpressure').addEventListener('input', function() {
                appState.updateConstants({ aquiferOverpressure: parseFloat(this.value) });
                updateSimulation();
            });
        }
        
        function setupOfftakeEventListeners() {
            document.getElementById('offtakeCustomName').addEventListener('input', function() {
                const stations = appState.getCurrentProject().config.stations;
                if (stations.length > 0) {
                    // Find the offtake station
                    const offtakeIndex = stations.findIndex(s => s.id === 'offtake');
                    if (offtakeIndex !== -1) {
                        appState.updateStation(offtakeIndex, {
                            customName: this.value,
                            name: this.value || 'Offtake'
                        });
                    }
                }
            });
            
            document.getElementById('offtakeDepth').addEventListener('input', function() {
                appState.updateOfftakeSettings({ offtakeDepth: parseFloat(this.value) });
                updateOfftakeVirginPressure();
                
                // Update the station's depth as well
                const stations = appState.getCurrentProject().config.stations;
                if (stations && stations.length > 0) {
                    const offtakeIndex = stations.findIndex(s => s.id === 'offtake');
                    if (offtakeIndex !== -1) {
                        appState.updateStation(offtakeIndex, {
                            depth: parseFloat(this.value)
                        });
                    }
                }
            });
            
            document.getElementById('useSplineInterpolation').addEventListener('change', function() {
                appState.updateOfftakeSettings({ useSplineInterpolation: this.checked });
            });
            
            // Add paste event listener for pressure table
            const pressureTable = document.getElementById('pressureTable');
            if (pressureTable) {
                pressureTable.addEventListener('paste', handlePressureTablePaste);
            }
        }
        
        function setupStationEventListeners() {
            currentStationIndex = currentInlineInputData;
            
            document.getElementById('modalCustomName').addEventListener('input', updateStationFromInline);
            document.getElementById('modalDistance').addEventListener('input', updateStationFromInline);
            document.getElementById('modalPermeability').addEventListener('input', updateStationFromInline);
            document.getElementById('modalHeight').addEventListener('input', updateStationFromInline);
            document.getElementById('modalWidth').addEventListener('input', updateStationFromInline);
            document.getElementById('modalNTG').addEventListener('input', updateStationFromInline);
            document.getElementById('modalPorosity').addEventListener('input', updateStationFromInline);
            document.getElementById('modalDepth').addEventListener('input', function() {
                updateStationFromInline();
                updateStationVirginPressure();
            });
        }
        
        function updateStationFromInline() {
            if (currentStationIndex === null) return;
            
            const project = appState.getCurrentProject();
            if (!project || !project.config.stations) return;
            
            const station = project.config.stations[currentStationIndex];
            const customName = document.getElementById('modalCustomName').value;
            const segmentDistance = parseFloat(document.getElementById('modalDistance').value);
            
            // Determine the default name based on position
            let defaultName;
            if (station.isLeft) {
                const leftStations = project.config.stations.filter(s => s.isLeft);
                const positionFromOfftake = leftStations.filter(s => s.id <= station.id).length;
                defaultName = `Station L${positionFromOfftake}`;
            } else if (station.id !== 'offtake') {
                const rightStations = project.config.stations.filter(s => !s.isLeft && s.id !== 'offtake');
                const positionFromOfftake = rightStations.filter(s => s.id <= station.id).length;
                defaultName = `Station R${positionFromOfftake}`;
            } else {
                defaultName = 'Offtake';
            }
            
            const updates = {
                customName: customName,
                name: customName || defaultName,
                segmentDistance: segmentDistance,
                isLeft: station.isLeft,
                height: parseFloat(document.getElementById('modalHeight').value),
                width: parseFloat(document.getElementById('modalWidth').value),
                ntg: parseFloat(document.getElementById('modalNTG').value),
                porosity: parseFloat(document.getElementById('modalPorosity').value),
                permeability: parseFloat(document.getElementById('modalPermeability').value),
                depth: parseFloat(document.getElementById('modalDepth').value)
            };
            
            // Update this station
            appState.updateStation(currentStationIndex, updates);
            
            // Update chart dataset label if chart exists
            if (stationPressureChart && stationPressureChart.data.datasets[currentStationIndex]) {
                stationPressureChart.data.datasets[currentStationIndex].label = updates.name;
                stationPressureChart.update();
            }
            
            renderStations();
            updateSimulation();
        }
        
        function handlePressureTablePaste(e) {
            e.preventDefault();
            
            const clipboardData = e.clipboardData || window.clipboardData;
            const pastedData = clipboardData.getData('text');
            
            // Parse the pasted data
            const rows = pastedData.trim().split('\n');
            const data = [];
            
            rows.forEach(row => {
                const cells = row.split(/\t|,|;|\s+/); // Support tab, comma, semicolon, or space delimited
                if (cells.length >= 2) {
                    const time = parseFloat(cells[0]);
                    const pressure = parseFloat(cells[1]);
                    if (!isNaN(time) && !isNaN(pressure) && time > 0) {
                        data.push({ time, pressure });
                    }
                }
            });
            
            if (data.length > 0) {
                // Clear existing rows (except the first hydrostatic row)
                const tbody = document.getElementById('pressureTableBody');
                const rows = Array.from(tbody.querySelectorAll('tr'));
                rows.slice(1).forEach(row => row.remove());
                
                // Add new rows
                data.forEach(entry => {
                    addPressureRowElement(entry.time, entry.pressure);
                });
                
                // Update the pressure data
                updatePressureTableData();
                
                showNotification(
                    `Pasted ${data.length} pressure entries`,
                    'success',
                    3000
                );
            }
        }
        
        // ===========================================
        // UI EVENT HANDLERS (NOW USE STATE MANAGER)
        // ===========================================
        
        // Time slider handler
        document.getElementById('timeSlider').addEventListener('input', function() {
            const time = parseFloat(this.value);
            appState.updateCurrentTime(time);
            
            // Check if we're at a custom time position
            const project = appState.getCurrentProject();
            if (project) {
                const startDate = project.config.startDate;
                const simulationLength = parseFloat(project.config.simulationLength);
                const customTimes = project.config.customTimes || [];
                
                let matchedIndex = null;
                
                for (let i = 0; i < customTimes.length; i++) {
                    const customTime = customTimes[i];
                    let timeValueForComparison = null;
                    
                    if (customTime.type === 'years') {
                        timeValueForComparison = parseFloat(parseFloat(customTime.years).toFixed(2));
                    } else if (customTime.type === 'date' && startDate) {
                        const start = new Date(startDate);
                        const target = new Date(customTime.date);
                        const diffTime = target - start;
                        const diffYearsRaw = diffTime / (1000 * 60 * 60 * 24 * 365.25);
                        
                        if (diffYearsRaw >= 0 && diffYearsRaw <= simulationLength) {
                            timeValueForComparison = parseFloat(diffYearsRaw.toFixed(2));
                        }
                    }
                    
                    if (timeValueForComparison !== null && Math.abs(time - timeValueForComparison) < 0.0001) {
                        matchedIndex = i;
                        break;
                    }
                }
                
                // Only update if changed
                if (matchedIndex !== project.config.selectedCustomTime) {
                    appState.updateSelectedCustomTime(matchedIndex);
                }
            }
            
            updateSimulation();
        });
        
        // Chart view toggle handler
        function toggleChartView() {
            const showDepletion = !document.getElementById('chartViewToggle').checked;
            appState.updateChartView(showDepletion);
        }
        
        // ===========================================
        // PHYSICS EQUATIONS (UPDATED WITH OVERPRESSURE)
        // ===========================================
        
        // Convert permeability from millidarcy to m
        function permeabilityMdToM2(k_md) {
            return k_md * 9.869233e-16;
        }
        
        // Convert viscosity from centipoise to Pas
        function viscosityCpToPas(viscosity_cp) {
            return viscosity_cp * 1e-3;
        }
        
        // Convert compressibility from 1/bar to 1/Pa
        function compressibilityBarToPa(comp_bar) {
            return comp_bar * 1e-5;
        }
        
        // Calculate transmissibility (Darcy's Law parameter)
        function calculateTransmissibility(k_m2, h_m, width_m, viscosity_pas) {
            return k_m2 * h_m * width_m / viscosity_pas;
        }
        
        // Calculate storativity
        function calculateStorativity(porosity, h_m, compressibility_pa) {
            return porosity * h_m * compressibility_pa;
        }
        
        // Calculate hydraulic diffusivity (true diffusivity)
        function calculateHydraulicDiffusivity(k_m2, porosity, viscosity_pas, compressibility_pa) {
            return k_m2 / (porosity * viscosity_pas * compressibility_pa);
        }
        
        // Calculate hydraulic conductivity
        function calculateHydraulicConductivity(k_m2, density_kgm3, viscosity_pas) {
            const g = 9.81; // m/s
            return k_m2 * density_kgm3 * g / viscosity_pas;
        }
        
        // Calculate dimensionless time
        function calculateDimensionlessTime(diffusivity_m2s, time_s, length_m) {
            return diffusivity_m2s * time_s / (length_m * length_m);
        }
        
        // Error function complement
        function erfc(x) {
            if (x === 0) return 1;
            if (x > 5) return 0;
            
            // Approximation for erfc
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;
            const p = 0.3275911;
            
            const absX = Math.abs(x);
            const t = 1.0 / (1.0 + p * absX);
            const poly = ((((a5 * t + a4) * t) + a3) * t + a2) * t + a1;
            const erfc_approx = t * poly * Math.exp(-absX * absX);
            
            return x >= 0 ? erfc_approx : 2 - erfc_approx;
        }
        
        // Calculate pressure propagation factor
        function calculatePressurePropagationFactor(tD) {
            if (tD <= 0) return 0;
            
            // Always use the erfc solution
            const arg = 0.5 / Math.sqrt(tD);
            return erfc(arg);
        }
        
        // ===========================================
        // UI FUNCTIONS (UPDATED TO USE STATE)
        // ===========================================
        
        // Get stations in their predictable order
        function getOrderedStations(stations) {
            return [...stations].sort((a, b) => {
                // Offtake always in the middle
                if (a.id === 'offtake') return b.isLeft ? 1 : -1;
                if (b.id === 'offtake') return a.isLeft ? -1 : 1;
                
                // Both are left stations - reverse order (L3, L2, L1)
                if (a.isLeft && b.isLeft) {
                    const aNum = parseInt(a.id.match(/\d+/)[0]);
                    const bNum = parseInt(b.id.match(/\d+/)[0]);
                    return bNum - aNum;
                }
                
                // Both are right stations - normal order (R1, R2, R3)
                if (!a.isLeft && !b.isLeft) {
                    const aNum = parseInt(a.id.match(/\d+/)[0]);
                    const bNum = parseInt(b.id.match(/\d+/)[0]);
                    return aNum - bNum;
                }
                
                // One is left, one is right
                return a.isLeft ? -1 : 1;
            });
        }
        
        // Render LaTeX equation
        function renderLatex(latex) {
            const span = document.createElement('span');
            const cleanLatex = latex.replace(//g, '\\times');
            try {
                katex.render(cleanLatex, span, { displayMode: true });
                return span.outerHTML;
            } catch (e) {
                console.error('KaTeX error:', e, 'LaTeX:', cleanLatex);
                return '<div class="equation">' + latex + '</div>';
            }
        }
        
        // Update header with project name
        function updateHeader() {
            const currentProject = appState.getCurrentProject();
            const headerText = currentProject ? currentProject.name : 'Aquifer Pressure Propagation Simulator';
            const subtitleText = currentProject && currentProject.description ? currentProject.description : '';
            
            document.getElementById('appHeader').textContent = headerText;
            document.title = headerText;
            
            const subtitleElement = document.getElementById('projectSubtitle');
            if (subtitleElement) {
                subtitleElement.textContent = subtitleText;
            }
        }
        
        // Update virgin pressure displays
        function updateOfftakeVirginPressure() {
            const depthInput = document.getElementById('offtakeDepth');
            if (!depthInput) return; // Guard against missing elements
            
            const depth = parseFloat(depthInput.value);
            const virginPressure = calculateHydrostaticPressure(depth);
            const virginPressureElement = document.getElementById('offtakeVirginPressure');
            if (virginPressureElement) {
                virginPressureElement.textContent = `Virgin pressure: ${virginPressure.toFixed(1)} bar`;
            }
        }
        
        function updateStationVirginPressure() {
            const depthInput = document.getElementById('modalDepth');
            if (!depthInput) return; // Guard against missing elements
            
            const depth = parseFloat(depthInput.value);
            const virginPressure = calculateHydrostaticPressure(depth);
            const virginPressureElement = document.getElementById('stationVirginPressure');
            if (virginPressureElement) {
                virginPressureElement.textContent = `Virgin pressure: ${virginPressure.toFixed(1)} bar`;
            }
        }
        
        // Load project to UI
        function loadProjectToUI(project) {
            const config = project.config;
            
            // Update header
            updateHeader();
            
            // Update virgin pressure display
            updateOfftakeVirginPressure();
            
            // Load time slider
            const maxTime = parseFloat(config.simulationLength || 10);
            const currentTime = Math.min(appState.getAppSettings().currentTime, maxTime);
            document.getElementById('timeSlider').max = maxTime;
            document.getElementById('timeSlider').value = currentTime;
            
            // Update chart view toggle
            const chartToggle = document.getElementById('chartViewToggle');
            if (chartToggle) {
                chartToggle.checked = !appState.getAppSettings().showDepletionChart;
            }
            
            // Close any open inline inputs
            closeInlineInput();
            
            // Update UI
            updateProjectNavigation();
            updateStations();
            initializeStationChart();
            updateSimulation();
            
            // Store initial pressures
            initialPressures = [];
            if (config.stations) {
                config.stations.forEach(station => {
                    initialPressures.push(calculateHydrostaticPressure(station.depth));
                });
            }
            
            // Update slider track
            updateSliderTrack();
        }
        
        // Update project navigation buttons
        function updateProjectNavigation() {
            const projects = appState.getProjects();
            const currentProject = appState.getCurrentProject();
            const currentIndex = projects.findIndex(p => p.id === currentProject?.id);
            
            const prevBtn = document.getElementById('prevProjectBtn');
            const nextBtn = document.getElementById('nextProjectBtn');
            
            prevBtn.disabled = currentIndex <= 0;
            nextBtn.disabled = currentIndex >= projects.length - 1;
        }
        
        // ===========================================
        // PROJECT MANAGEMENT FUNCTIONS
        // ===========================================
        
        function showProjectModal() {
            document.getElementById('projectModal').style.display = 'block';
            updateProjectList();
            clearProjectForm();
        }
        
        function updateProjectList() {
            const list = document.getElementById('projectList');
            const projects = appState.getProjects();
            const currentProject = appState.getCurrentProject();
            
            if (projects.length === 0) {
                list.innerHTML = '<p style="color: #999; text-align: center;">No projects found</p>';
                return;
            }
            
            let html = '';
            projects.forEach((project, index) => {
                const isActive = project.id === currentProject?.id;
                const created = new Date(project.created).toLocaleDateString();
                const modified = new Date(project.modified).toLocaleDateString();
                
                html += `<div class="project-item ${isActive ? 'active' : ''}" onclick="selectProject('${project.id}')">
                    <div class="project-info">
                        <div class="project-title">${project.name}</div>`;
                
                if (project.description) {
                    html += `<div class="project-description">${project.description}</div>`;
                }
                
                html += `<div class="project-date">Created: ${created} | Modified: ${modified}</div>
                    </div>
                    <div class="project-actions">
                        <button onclick="editProject('${project.id}'); event.stopPropagation();" title="Edit">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button onclick="duplicateProject('${project.id}'); event.stopPropagation();" title="Duplicate">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="danger" onclick="deleteProject('${project.id}'); event.stopPropagation();" title="Delete">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>`;
            });
            
            list.innerHTML = html;
        }
        
        function selectProject(projectId) {
            if (projectId !== appState.state.currentProjectId) {
                appState.switchProject(projectId);
            }
        }
        
        function editProject(projectId) {
            const project = appState.getProject(projectId);
            if (!project) return;
            
            document.getElementById('editingProjectIndex').value = projectId;
            document.getElementById('projectName').value = project.name;
            document.getElementById('projectDescription').value = project.description || '';
            document.getElementById('isDuplicating').value = 'false';
            document.getElementById('duplicateIndicator').style.display = 'none';
        }
        
        function duplicateProject(projectId) {
            const original = appState.getProject(projectId);
            if (!original) return;
            
            document.getElementById('editingProjectIndex').value = -1;
            document.getElementById('projectName').value = original.name + ' (Copy)';
            document.getElementById('projectDescription').value = original.description || '';
            document.getElementById('isDuplicating').value = projectId;
            document.getElementById('duplicateIndicator').style.display = 'block';
        }
        
        function deleteProject(projectId) {
            const projects = appState.getProjects();
            if (projects.length <= 1) {
                showNotification(
                    'You must keep at least one project',
                    'warning',
                    3000,
                    'Cannot Delete'
                );
                return;
            }
            
            if (confirm('Are you sure you want to delete this project?')) {
                appState.deleteProject(projectId);
                showNotification(
                    'Project deleted successfully',
                    'info',
                    3000
                );
            }
        }
        
        function clearProjectForm() {
            document.getElementById('editingProjectIndex').value = '-1';
            document.getElementById('projectName').value = '';
            document.getElementById('projectDescription').value = '';
            document.getElementById('isDuplicating').value = 'false';
            document.getElementById('duplicateIndicator').style.display = 'none';
        }
        
        function saveProject() {
            const name = document.getElementById('projectName').value.trim();
            const description = document.getElementById('projectDescription').value.trim();
            const editingId = document.getElementById('editingProjectIndex').value;
            const duplicatingId = document.getElementById('isDuplicating').value;
            
            if (!name) {
                showNotification(
                    'Please enter a project name',
                    'warning',
                    3000,
                    'Name Required'
                );
                return;
            }
            
            if (editingId !== '-1') {
                // Update existing project
                appState.updateProject(editingId, { name, description });
                showNotification(
                    'Project updated successfully',
                    'success',
                    3000
                );
            } else if (duplicatingId !== 'false') {
                // Duplicate project
                const duplicate = appState.duplicateProject(duplicatingId);
                if (duplicate) {
                    appState.updateProject(duplicate.id, { name, description });
                    appState.switchProject(duplicate.id);
                    showNotification(
                        'Project duplicated successfully',
                        'success',
                        3000
                    );
                }
            } else {
                // Create new project
                const newProject = appState.createProject(name, description);
                appState.switchProject(newProject.id);
                showNotification(
                    'New project created successfully',
                    'success',
                    3000
                );
            }
            
            clearProjectForm();
            updateProjectList();
            updateHeader();
        }
        
        // ===========================================
        // IMPORT/EXPORT FUNCTIONS
        // ===========================================
        
        function showImportModal() {
            document.getElementById('importModal').style.display = 'block';
            document.getElementById('importFile').value = '';
            document.getElementById('importList').style.display = 'none';
            document.getElementById('importActions').style.display = 'none';
            importProjects = [];
        }
        
        function showExportModal() {
            document.getElementById('exportModal').style.display = 'block';
            selectedExportProjects.clear();
            updateExportList();
        }
        
        function handleImportFiles() {
            const fileInput = document.getElementById('importFile');
            const files = fileInput.files;
            
            if (!files || files.length === 0) return;
            
            importProjects = [];
            let filesProcessed = 0;
            
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (Array.isArray(data)) {
                            importProjects.push(...data);
                        } else if (data.projects) {
                            importProjects.push(...data.projects);
                        } else {
                            importProjects.push(data);
                        }
                        
                        filesProcessed++;
                        if (filesProcessed === files.length) {
                            displayImportList();
                        }
                    } catch (error) {
                        showNotification(
                            `Error reading file ${file.name}: Invalid JSON format`,
                            'error',
                            5000,
                            'Import Error'
                        );
                        console.error(error);
                        filesProcessed++;
                        if (filesProcessed === files.length && importProjects.length > 0) {
                            displayImportList();
                        }
                    }
                };
                
                reader.readAsText(file);
            });
        }
        
        function displayImportList() {
            const list = document.getElementById('importList');
            const existingNames = appState.getProjects().map(p => p.name.toLowerCase());
            
            let html = '';
            importProjects.forEach((project, index) => {
                const hasConflict = existingNames.includes(project.name.toLowerCase());
                
                html += `<div class="import-item ${hasConflict ? 'conflict' : ''}" data-index="${index}">
                    <input type="checkbox" class="import-item-checkbox" id="import-${index}" 
                           ${hasConflict ? '' : 'checked'}>
                    <div class="import-item-info">
                        <div class="import-item-title">
                            <span>${project.name}</span>
                            ${hasConflict ? '<span class="conflict-indicator">(name exists)</span>' : ''}
                        </div>
                        <div class="import-item-edit">
                            <input type="text" value="${project.name}" id="import-name-${index}">
                            <button class="icon-btn primary" onclick="saveImportRename(${index})">
                                <i class="fas fa-check"></i>
                            </button>
                            <button class="icon-btn" onclick="cancelImportRename(${index})">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>`;
                
                if (project.description) {
                    html += `<div class="project-description">${project.description}</div>`;
                }
                
                html += `</div>
                    <div class="import-item-actions">
                        <button onclick="toggleImportEdit(${index})" title="Edit Name">
                            <i class="fas fa-pen"></i>
                        </button>
                    </div>
                </div>`;
            });
            
            list.innerHTML = html;
            list.style.display = 'block';
            document.getElementById('importActions').style.display = 'flex';
        }
        
        function toggleImportEdit(index) {
            const item = document.querySelector(`.import-item[data-index="${index}"]`);
            item.classList.toggle('editing');
            
            if (item.classList.contains('editing')) {
                const input = document.getElementById(`import-name-${index}`);
                input.focus();
                input.select();
            }
        }
        
        function saveImportRename(index) {
            const input = document.getElementById(`import-name-${index}`);
            const newName = input.value.trim();
            
            if (!newName) {
                showNotification(
                    'Project name cannot be empty',
                    'warning',
                    3000,
                    'Name Required'
                );
                return;
            }
            
            importProjects[index].name = newName;
            displayImportList();
        }
        
        function cancelImportRename(index) {
            toggleImportEdit(index);
        }
        
        function performImport() {
            const selectedProjects = [];
            importProjects.forEach((project, index) => {
                const checkbox = document.getElementById(`import-${index}`);
                if (checkbox.checked) {
                    selectedProjects.push(project);
                }
            });
            
            if (selectedProjects.length === 0) {
                showNotification(
                    'Please select at least one project to import',
                    'warning',
                    3000,
                    'No Selection'
                );
                return;
            }
            
            appState.importProjects(selectedProjects);
            closeModal('importModal');
            
            showNotification(
                `Successfully imported ${selectedProjects.length} project${selectedProjects.length > 1 ? 's' : ''}`,
                'success',
                4000,
                'Import Complete'
            );
        }
        
        function updateExportList() {
            const list = document.getElementById('exportList');
            const projects = appState.getProjects();
            
            let html = '';
            projects.forEach(project => {
                const isSelected = selectedExportProjects.has(project.id);
                
                html += `<div class="export-item ${isSelected ? 'selected' : ''}" 
                         onclick="toggleExportProject('${project.id}')">
                    <input type="checkbox" class="export-item-checkbox" 
                           ${isSelected ? 'checked' : ''} 
                           onchange="toggleExportProject('${project.id}'); event.stopPropagation()">
                    <div class="project-info">
                        <div class="project-title">${project.name}</div>`;
                
                if (project.description) {
                    html += `<div class="project-description">${project.description}</div>`;
                }
                
                const created = new Date(project.created).toLocaleDateString();
                const modified = new Date(project.modified).toLocaleDateString();
                html += `<div class="project-date">Created: ${created} | Modified: ${modified}</div>
                    </div>
                </div>`;
            });
            
            list.innerHTML = html;
            
            const selectAllCheckbox = document.getElementById('selectAllExport');
            selectAllCheckbox.checked = selectedExportProjects.size === projects.length;
        }
        
        function toggleExportProject(projectId) {
            if (selectedExportProjects.has(projectId)) {
                selectedExportProjects.delete(projectId);
            } else {
                selectedExportProjects.add(projectId);
            }
            updateExportList();
        }
        
        function toggleSelectAllExport() {
            const selectAll = document.getElementById('selectAllExport').checked;
            const projects = appState.getProjects();
            
            if (selectAll) {
                projects.forEach(project => selectedExportProjects.add(project.id));
            } else {
                selectedExportProjects.clear();
            }
            
            updateExportList();
        }
        
        function performExport() {
            if (selectedExportProjects.size === 0) {
                showNotification(
                    'Please select at least one project to export',
                    'warning',
                    3000,
                    'No Selection'
                );
                return;
            }
            
            const projectsToExport = appState.exportProjects(Array.from(selectedExportProjects));
            
            const exportData = projectsToExport.length === 1 
                ? projectsToExport[0]
                : projectsToExport;
            
            const filename = projectsToExport.length === 1 
                ? `${projectsToExport[0].name.replace(/[^a-z0-9]/gi, '_')}_${Date.now()}.json`
                : `aquifer_projects_${projectsToExport.length}_${Date.now()}.json`;
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            closeModal('exportModal');
            selectedExportProjects.clear();
            
            showNotification(
                `Exported ${projectsToExport.length} project${projectsToExport.length > 1 ? 's' : ''} to ${filename}`,
                'success',
                4000,
                'Export Complete'
            );
        }
        
        // ===========================================
        // CUSTOM TIME FUNCTIONS
        // ===========================================
        
        function toggleTimeDropdown() {
            const dropdown = document.getElementById('timeDropdown');
            const header = document.getElementById('timeSliderHeader');
            
            dropdown.classList.toggle('active');
            header.classList.toggle('active');
            
            if (dropdown.classList.contains('active')) {
                populateTimeDropdown();
            }
        }
        
        function populateTimeDropdown() {
            const content = document.getElementById('timeDropdownContent');
            const project = appState.getCurrentProject();
            if (!project) return;
            
            const currentTime = parseFloat(document.getElementById('timeSlider').value);
            const startDate = project.config.startDate;
            const simulationLength = parseFloat(project.config.simulationLength);
            const customTimes = project.config.customTimes || [];
            
            let html = '';
            
            if (customTimes.length > 0) {
                customTimes.forEach((customTime, index) => {
                    let displayText = customTime.title;
                    let timeValue = null;
                    
                    if (customTime.type === 'years') {
                        timeValue = customTime.years;
                        displayText += ` (${customTime.years} years)`;
                    } else if (customTime.type === 'date' && startDate) {
                        const start = new Date(startDate);
                        const target = new Date(customTime.date);
                        const diffTime = target - start;
                        const diffYears = diffTime / (1000 * 60 * 60 * 24 * 365.25);
                        
                        if (diffYears >= 0 && diffYears <= simulationLength) {
                            timeValue = diffYears;
                            displayText += ` (${target.toLocaleDateString()})`;
                        }
                    }
                    
                    if (timeValue !== null && timeValue >= 0 && timeValue <= simulationLength) {
                        const isSelected = Math.abs(currentTime - timeValue) < 0.001;
                        html += `<div class="time-dropdown-item ${isSelected ? 'selected' : ''}" onclick="selectTime(${timeValue}, ${index})">
                            ${displayText}
                        </div>`;
                    }
                });
            } else {
                html = '<div class="time-dropdown-empty">No custom times defined</div>';
            }
            
            content.innerHTML = html;
        }
        
        function selectTime(years, customTimeIndex) {
            document.getElementById('timeSlider').value = years;
            appState.updateCurrentTime(years);
            
            const project = appState.getCurrentProject();
            if (project && project.config.selectedCustomTime !== customTimeIndex) {
                appState.updateSelectedCustomTime(customTimeIndex);
            }
            
            updateSimulation();
            toggleTimeDropdown();
        }
        
        function showCustomTimesModal() {
            event.stopPropagation();
            document.getElementById('customTimesModal').style.display = 'block';
            updateCustomTimesList();
            clearCustomTimeForm();
        }
        
        function onTimeInputChange(type) {
            const yearsInput = document.getElementById('customTimeYears');
            const dateInput = document.getElementById('customTimeDate');
            
            if (type === 'years' && yearsInput.value) {
                dateInput.disabled = true;
            } else if (type === 'date' && dateInput.value) {
                yearsInput.disabled = true;
            } else {
                yearsInput.disabled = false;
                dateInput.disabled = false;
            }
        }
        
        function clearCustomTimeForm() {
            document.getElementById('editingIndex').value = '-1';
            document.getElementById('customTimeTitle').value = '';
            document.getElementById('customTimeYears').value = '';
            document.getElementById('customTimeDate').value = '';
            document.getElementById('customTimeDescription').value = '';
            document.getElementById('customTimeYears').disabled = false;
            document.getElementById('customTimeDate').disabled = false;
        }
        
        function saveCustomTime() {
            const title = document.getElementById('customTimeTitle').value.trim();
            const years = document.getElementById('customTimeYears').value;
            const date = document.getElementById('customTimeDate').value;
            const description = document.getElementById('customTimeDescription').value.trim();
            const editingIndex = parseInt(document.getElementById('editingIndex').value);
            
            if (!title) {
                showNotification(
                    'Please enter a title for the custom time',
                    'warning',
                    3000,
                    'Title Required'
                );
                return;
            }
            
            if (!years && !date) {
                showNotification(
                    'Please enter either years or a date',
                    'warning',
                    3000,
                    'Time Required'
                );
                return;
            }
            
            const project = appState.getCurrentProject();
            if (!project) return;
            
            const customTimes = [...(project.config.customTimes || [])];
            
            const customTime = {
                title: title,
                description: description
            };
            
            if (years) {
                customTime.type = 'years';
                customTime.years = parseFloat(years);
            } else {
                customTime.type = 'date';
                customTime.date = date;
            }
            
            if (editingIndex >= 0) {
                customTimes[editingIndex] = customTime;
                showNotification(
                    'Custom time updated successfully',
                    'success',
                    3000
                );
            } else {
                customTimes.push(customTime);
                showNotification(
                    'Custom time added successfully',
                    'success',
                    3000
                );
            }
            
            appState.updateCustomTimes(customTimes);
            clearCustomTimeForm();
            updateCustomTimesList();
        }
        
        function editCustomTime(index) {
            const project = appState.getCurrentProject();
            if (!project) return;
            
            const customTime = project.config.customTimes[index];
            if (!customTime) return;
            
            document.getElementById('editingIndex').value = index;
            document.getElementById('customTimeTitle').value = customTime.title;
            document.getElementById('customTimeDescription').value = customTime.description || '';
            
            if (customTime.type === 'years') {
                document.getElementById('customTimeYears').value = customTime.years;
                document.getElementById('customTimeDate').value = '';
                document.getElementById('customTimeDate').disabled = true;
            } else {
                document.getElementById('customTimeDate').value = customTime.date;
                document.getElementById('customTimeYears').value = '';
                document.getElementById('customTimeYears').disabled = true;
            }
        }
        
        function deleteCustomTime(index) {
            if (confirm('Are you sure you want to delete this custom time?')) {
                const project = appState.getCurrentProject();
                if (!project) return;
                
                const customTimes = [...(project.config.customTimes || [])];
                customTimes.splice(index, 1);
                
                // Calculate new selected index
                let newSelectedTime = project.config.selectedCustomTime;
                if (newSelectedTime === index) {
                    newSelectedTime = null;
                } else if (newSelectedTime > index) {
                    newSelectedTime = newSelectedTime - 1;
                }
                
                // Update both together
                appState.updateCustomTimesAndSelection(customTimes, newSelectedTime);
                updateCustomTimesList();
                showNotification(
                    'Custom time deleted successfully',
                    'info',
                    3000
                );
            }
        }
        
        function updateCustomTimesList() {
            const list = document.getElementById('customTimeList');
            const project = appState.getCurrentProject();
            
            if (!project || !project.config.customTimes || project.config.customTimes.length === 0) {
                list.innerHTML = '<p style="color: #999; text-align: center;">No custom times defined</p>';
                return;
            }
            
            let html = '';
            project.config.customTimes.forEach((customTime, index) => {
                html += `<div class="custom-time-item">
                    <div class="custom-time-info">
                        <div class="custom-time-title">${customTime.title}</div>`;
                
                if (customTime.description) {
                    html += `<div class="custom-time-description">${customTime.description}</div>`;
                }
                
                if (customTime.type === 'years') {
                    html += `<div class="custom-time-value">${customTime.years} years from start</div>`;
                } else {
                    html += `<div class="custom-time-value">Date: ${new Date(customTime.date).toLocaleDateString()}</div>`;
                }
                
                html += `</div>
                    <div class="custom-time-actions">
                        <button onclick="editCustomTime(${index})" title="Edit">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="danger" onclick="deleteCustomTime(${index})" title="Delete">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>`;
            });
            
            list.innerHTML = html;
        }
        
        function updateTimeSliderLabel() {
            const currentTime = parseFloat(document.getElementById('timeSlider').value);
            const label = document.getElementById('timeSliderLabel');
            const header = document.getElementById('timeSliderHeader');
            
            const project = appState.getCurrentProject();
            if (!project) return;
            
            const startDate = project.config.startDate;
            const simulationLength = parseFloat(project.config.simulationLength);
            const customTimes = project.config.customTimes || [];
            
            header.onmouseenter = null;
            header.onmouseleave = null;
            
            let matchedCustomTime = null;
            
            for (let i = 0; i < customTimes.length; i++) {
                const customTime = customTimes[i];
                let timeValueForComparison = null;
                
                if (customTime.type === 'years') {
                    timeValueForComparison = parseFloat(parseFloat(customTime.years).toFixed(2));
                } else if (customTime.type === 'date' && startDate) {
                    const start = new Date(startDate);
                    const target = new Date(customTime.date);
                    const diffTime = target - start;
                    const diffYearsRaw = diffTime / (1000 * 60 * 60 * 24 * 365.25);
                    
                    if (diffYearsRaw >= 0 && diffYearsRaw <= simulationLength) {
                        timeValueForComparison = parseFloat(diffYearsRaw.toFixed(2));
                    }
                }
                
                if (timeValueForComparison !== null && Math.abs(currentTime - timeValueForComparison) < 0.0001) {
                    matchedCustomTime = customTime;
                    break;
                }
            }
            
            if (matchedCustomTime) {
                label.innerHTML = `${matchedCustomTime.title}: <span id="currentTime">${currentTime.toFixed(2)}</span> years`;
                
                if (matchedCustomTime.description) {
                    const arrowIcon = header.querySelector('.dropdown-arrow');
                    header.onmouseenter = () => showTooltip(header, matchedCustomTime.description, arrowIcon);
                    header.onmouseleave = hideTooltip;
                }
            } else {
                label.innerHTML = `Time: <span id="currentTime">${currentTime.toFixed(2)}</span> years`;
            }
        }
        
        function showTooltip(hoveredElement, text, positioningTargetElement) {
            const tooltip = document.getElementById('tooltip');
            tooltip.textContent = text;
            
            const elementToPositionAgainst = positioningTargetElement || hoveredElement;
            const targetRect = elementToPositionAgainst.getBoundingClientRect();
            
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            
            const tooltipLeft = targetRect.left + scrollLeft + (targetRect.width / 2);
            
            const gap = 8;
            const tooltipArrowHeight = 6;
            const tooltipTop = targetRect.bottom + scrollTop + gap + tooltipArrowHeight;
            
            tooltip.style.left = tooltipLeft + 'px';
            tooltip.style.top = tooltipTop + 'px';
            
            tooltip.classList.add('active');
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('active');
        }
        
        // Click outside to close dropdown
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('timeDropdown');
            const header = document.getElementById('timeSliderHeader');
            
            if (!header.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.classList.remove('active');
                header.classList.remove('active');
            }
        });
        
        // ===========================================
        // STATION MANAGEMENT
        // ===========================================
        
        function updateSliderTrack() {
            const slider = document.getElementById('timeSlider');
            const track = document.getElementById('sliderTrack');
            const percent = (slider.value - slider.min) / (slider.max - slider.min);
            
            // Account for thumb width (24px) - thumb is centered on position
            // So we need to adjust the track to align with the center of the thumb
            const thumbRadius = 12; // Half of 24px thumb width
            const containerWidth = slider.offsetWidth;
            const effectiveWidth = containerWidth - (2 * thumbRadius);
            const pixelOffset = thumbRadius;
            
            // Calculate the actual width in pixels
            const trackWidth = (effectiveWidth * percent) + thumbRadius;
            
            // Set both width and left position
            track.style.width = trackWidth + 'px';
            track.style.left = '0px';
        }
        
        function formatTimeDisplay(years) {
            const project = appState.getCurrentProject();
            if (!project) return `${years.toFixed(2)} years since start`;
            
            const startDateInput = project.config.startDate;
            
            if (startDateInput) {
                const startDate = new Date(startDateInput);
                const currentDate = new Date(startDate);
                currentDate.setDate(currentDate.getDate() + years * 365.25);
                
                const options = { day: 'numeric', month: 'long', year: 'numeric' };
                return currentDate.toLocaleDateString('en-US', options);
            } else {
                return `${years.toFixed(2)} years since start`;
            }
        }
        
        function updateDebugViewForStation(stationIndex) {
            if (!document.getElementById('calculationInfo').classList.contains('active')) return;
            
            lastHoveredStation = stationIndex;
            const time = parseFloat(document.getElementById('timeSlider').value);
            const project = appState.getCurrentProject();
            
            if (!project || !project.config.stations || !window.lastSegmentProps) return;
            
            const stations = project.config.stations;
            
            const debugInfo = document.getElementById('debugInfo');
            debugInfo.innerHTML = `<strong>Showing calculations for ${stations[stationIndex].name}</strong> at t = ${time.toFixed(2)} years`;
            
            const details = document.getElementById('calculationDetails');
            details.style.display = 'block';
            
            let html = '<h4>Detailed Pressure Calculation for ' + stations[stationIndex].name + 
                       ' at t = ' + time.toFixed(2) + ' years</h4>';
            
            // Find the offtake station index
            const offtakeIndex = stations.findIndex(s => s.id === 'offtake');
            
            if (stationIndex === offtakeIndex) {
                const hydrostaticPressure = calculateHydrostaticPressure(stations[offtakeIndex].depth);
                const offtakePressure = time === 0 ? hydrostaticPressure : interpolatePressure(time);
                const depletion = hydrostaticPressure - offtakePressure;
                
                html += '<div class="calculation-section">';
                html += '<h5>Offtake Pressure</h5>';
                html += renderLatex('P_{hydrostatic} = \\rho g h + P_{overpressure} = ' + hydrostaticPressure.toFixed(2) + ' \\text{ bar}');
                html += '<div class="calc-value">Current Pressure: ' + offtakePressure.toFixed(2) + ' bar</div>';
                html += '<div class="calc-value">Depletion: ' + depletion.toFixed(2) + ' bar</div>';
                html += '</div>';
            } else {
                // Find the previous station in the ordered array
                const orderedStations = getOrderedStations(stations);
                const orderedIndex = orderedStations.findIndex(s => s === stations[stationIndex]);
                
                if (orderedIndex > 0) {
                    const prevStation = orderedStations[orderedIndex - 1];
                    const prevStationIndex = stations.indexOf(prevStation);
                    const currStation = stations[stationIndex];
                    
                    const waterDensity = parseFloat(project.config.waterDensity) * 1000;
                    const waterViscosity_cp = parseFloat(project.config.waterViscosity);
                    const waterCompressibility_bar = parseFloat(project.config.waterCompressibility);
                    const rockCompressibility_bar = parseFloat(project.config.rockCompressibility);
                    
                    const waterViscosity_pas = viscosityCpToPas(waterViscosity_cp);
                    const totalCompressibility_bar = rockCompressibility_bar + waterCompressibility_bar;
                    const totalCompressibility_pa = compressibilityBarToPa(totalCompressibility_bar);
                    
                    const t_s = time * 365.25 * 24 * 3600;
                    const distance_m = currStation.segmentDistance * 1000;
                    
                    // Get properties from the appropriate station
                    let props;
                    if (prevStation.id === 'offtake') {
                        // Previous station is offtake, use current station's properties
                        props = currStation;
                    } else if (currStation.id === 'offtake') {
                        // Current station is offtake, use previous station's properties
                        props = prevStation;
                    } else {
                        // Neither is offtake - use the station farther from offtake
                        props = currStation;
                    }
                    
                    const k_md = props.permeability;
                    const k_m2 = permeabilityMdToM2(k_md);
                    const effectiveK = k_m2 * props.ntg;
                    const trueDiffusivity = calculateHydraulicDiffusivity(effectiveK, props.porosity, waterViscosity_pas, totalCompressibility_pa);
                    
                    const tD = calculateDimensionlessTime(trueDiffusivity, t_s, distance_m);
                    const propagationFactor = calculatePressurePropagationFactor(tD);
                    
                    const prevPressures = calculateStepwisePressures(time, window.lastSegmentProps);
                    const prevPressure = prevPressures[prevStationIndex];
                    const prevHydrostatic = calculateHydrostaticPressure(prevStation.depth);
                    const currHydrostatic = calculateHydrostaticPressure(currStation.depth);
                    const pressureChange = prevPressure - prevHydrostatic;
                    const currentPressure = currHydrostatic + pressureChange * propagationFactor;
                    const depletion = currHydrostatic - currentPressure;
                    
                    html += '<div class="calculation-section">';
                    html += '<h5>1. Segment Properties</h5>';
                    html += renderLatex('k = ' + k_md.toFixed(1) + ' \\text{ mD} = ' + 
                                       formatScientific(k_m2) + ' \\text{ m}^2');
                    html += renderLatex('\\phi = ' + props.porosity.toFixed(3));
                    html += renderLatex('\\mu = ' + waterViscosity_cp + ' \\text{ cP} = ' + 
                                       formatScientific(waterViscosity_pas) + ' \\text{ Pa}\\text{s}');
                    html += renderLatex('C_t = ' + formatScientific(totalCompressibility_bar) + ' \\text{ bar}^{-1} = ' + 
                                       formatScientific(totalCompressibility_pa) + ' \\text{ Pa}^{-1}');
                    html += '</div>';
                    
                    html += '<div class="calculation-section">';
                    html += '<h5>2. Hydraulic Diffusivity</h5>';
                    html += renderLatex('\\eta_p = \\frac{k}{\\phi \\mu C_t} = \\frac{' + 
                                       formatScientific(effectiveK) + '}{' + 
                                       props.porosity.toFixed(3) + ' \\times ' + 
                                       formatScientific(waterViscosity_pas) + ' \\times ' + 
                                       formatScientific(totalCompressibility_pa) + '}');
                    html += renderLatex('\\eta_p = ' + formatScientific(trueDiffusivity) + ' \\text{ m}^2/\\text{s}');
                    html += '</div>';
                    
                    html += '<div class="calculation-section">';
                    html += '<h5>3. Dimensionless Time</h5>';
                    html += renderLatex('t = ' + time.toFixed(2) + ' \\text{ years} = ' + formatScientific(t_s) + ' \\text{ s}');
                    html += renderLatex('L = ' + (distance_m/1000).toFixed(1) + ' \\text{ km} = ' + distance_m + ' \\text{ m}');
                    html += renderLatex('t_D = \\frac{\\eta_p t}{L^2} = \\frac{' + 
                                       formatScientific(trueDiffusivity) + ' \\times ' + 
                                       formatScientific(t_s) + '}{(' + distance_m + ')^2}');
                    html += renderLatex('t_D = ' + tD.toFixed(4));
                    html += '</div>';
                    
                    html += '<div class="calculation-section">';
                    html += '<h5>4. Pressure Propagation Factor</h5>';
                    html += renderLatex('\\text{arg} = \\frac{0.5}{\\sqrt{t_D}} = \\frac{0.5}{\\sqrt{' + 
                                       tD.toFixed(4) + '}} = ' + (0.5/Math.sqrt(tD)).toFixed(4));
                    html += renderLatex('\\text{PropagationFactor} = \\text{erfc}(' + 
                                       (0.5/Math.sqrt(tD)).toFixed(4) + ') = ' + propagationFactor.toFixed(4));
                    html += '<div class="calc-value">This means ' + (propagationFactor * 100).toFixed(1) + 
                            '% of the pressure change is transmitted</div>';
                    html += '</div>';
                    
                    html += '<div class="calculation-section">';
                    html += '<h5>5. Pressure Calculation</h5>';
                    html += renderLatex('P_{hydrostatic,prev} = ' + prevHydrostatic.toFixed(2) + ' \\text{ bar}');
                    html += renderLatex('P_{prev} = ' + prevPressure.toFixed(2) + ' \\text{ bar}');
                    html += renderLatex('\\Delta P_{prev} = P_{prev} - P_{hydrostatic,prev} = ' + 
                                       pressureChange.toFixed(2) + ' \\text{ bar}');
                    html += renderLatex('P_{hydrostatic,curr} = ' + currHydrostatic.toFixed(2) + ' \\text{ bar}');
                    html += renderLatex('P_{curr} = P_{hydrostatic,curr} + \\Delta P_{prev} \\times \\text{PropagationFactor}');
                    html += renderLatex('P_{curr} = ' + currHydrostatic.toFixed(2) + ' + ' + 
                                       pressureChange.toFixed(2) + ' \\times ' + propagationFactor.toFixed(4));
                    html += renderLatex('P_{curr} = ' + currentPressure.toFixed(2) + ' \\text{ bar}');
                    html += '<div class="calc-value">Depletion: ' + depletion.toFixed(2) + ' bar</div>';
                    html += '</div>';
                    
                    // Add segment information for clarity
                    html += '<div class="calculation-section">';
                    html += '<h5>Note on Property Assignment</h5>';
                    html += '<div class="calc-value">Using all rock properties from ' + props.name + ':</div>';
                    html += '<div class="calc-value">- Permeability: ' + props.permeability.toFixed(0) + ' mD</div>';
                    html += '<div class="calc-value">- Porosity: ' + props.porosity.toFixed(3) + '</div>';
                    html += '<div class="calc-value">- Height: ' + props.height.toFixed(0) + ' m</div>';
                    html += '<div class="calc-value">- Width: ' + props.width.toFixed(1) + ' km</div>';
                    html += '<div class="calc-value">- NTG: ' + props.ntg.toFixed(3) + '</div>';
                    html += '<div class="calc-value">This represents the rock properties in the segment between ' + 
                            prevStation.name + ' and ' + currStation.name + '</div>';
                    html += '<div class="calc-value">The station farther from the offtake defines all segment properties</div>';
                    html += '</div>';
                }
            }
            
            details.innerHTML = html;
        }
        
        // Debounced version of updateDebugViewForStation
        function updateDebugViewForStationDebounced(stationIndex) {
            if (calculationUpdateTimeout) {
                clearTimeout(calculationUpdateTimeout);
            }
            
            // Show loading indicator on details (don't hide them)
            const details = document.getElementById('calculationDetails');
            if (details && details.style.display !== 'none') {
                details.style.opacity = '0.5';
                details.style.pointerEvents = 'none';
            }
            
            calculationUpdateTimeout = setTimeout(() => {
                try {
                    updateDebugViewForStation(stationIndex);
                } catch (error) {
                    console.error('Error updating calculation view:', error);
                } finally {
                    // Always ensure loading indicator is removed
                    const detailsElement = document.getElementById('calculationDetails');
                    if (detailsElement) {
                        detailsElement.style.opacity = '1';
                        detailsElement.style.pointerEvents = 'auto';
                    }
                    calculationUpdateTimeout = null;
                }
            }, CALCULATION_UPDATE_DELAY);
        }
        
        function toggleCalculationInfo() {
            const info = document.getElementById('calculationInfo');
            const btn = document.querySelector('.info-toggle-btn');
            
            info.classList.toggle('active');
            
            if (info.classList.contains('active')) {
                // Clear any pending debounced updates
                if (calculationUpdateTimeout) {
                    clearTimeout(calculationUpdateTimeout);
                }
                // Show immediately when toggling on
                updateDebugViewForStation(lastHoveredStation);
            } else {
                // Clear pending updates when closing
                if (calculationUpdateTimeout) {
                    clearTimeout(calculationUpdateTimeout);
                    calculationUpdateTimeout = null;
                }
                // Reset opacity
                const details = document.getElementById('calculationDetails');
                if (details) {
                    details.style.opacity = '1';
                    details.style.pointerEvents = 'auto';
                }
            }
        }
        
        function updateStations() {
            const project = appState.getCurrentProject();
            if (!project) return;
            
            const numStations = parseInt(project.config.numStations);
            const numStationsLeft = parseInt(project.config.numStationsLeft || 0);
            const existingStations = project.config.stations || [];
            
            const stations = [];
            const stationMap = new Map();
            
            // Create a map of existing stations by ID for easy lookup
            existingStations.forEach(station => {
                stationMap.set(station.id, station);
            });
            
            // First find or create the offtake station
            let offtakeStation = existingStations.find(s => s.id === 'offtake');
            
            if (!offtakeStation) {
                // Create new offtake station
                offtakeStation = {
                    id: 'offtake',
                    name: 'Offtake',
                    customName: '',
                    segmentDistance: 0,
                    isLeft: false,
                    height: 40,
                    width: 1,
                    ntg: 0.8,
                    porosity: 0.25,
                    permeability: 500,
                    depth: project.config.offtakeDepth || 2000
                };
            } else {
                // Preserve existing offtake station
                offtakeStation.isLeft = false; // Ensure property exists
                if (offtakeStation.customName) {
                    offtakeStation.name = offtakeStation.customName;
                }
                // Ensure offtake station depth matches the configured offtake depth
                offtakeStation.depth = project.config.offtakeDepth || 2000;
                // Ensure segmentDistance exists
                if (offtakeStation.segmentDistance === undefined) {
                    offtakeStation.segmentDistance = 0;
                }
            }
            
            // Add left stations (reversed order)
            for (let i = numStationsLeft; i > 0; i--) {
                const targetId = `station_left_${i}`;
                
                // Try to find existing station
                let existingStation = stationMap.get(targetId);
                
                if (!existingStation) {
                    // Create new station
                    existingStation = {
                        id: targetId,
                        name: `Station L${i}`,
                        customName: '',
                        segmentDistance: 10,
                        isLeft: true,
                        height: 40,
                        width: 1,
                        ntg: 0.8,
                        porosity: 0.25,
                        permeability: 100,
                        depth: 2000
                    };
                } else {
                    // Preserve existing station data
                    existingStation.isLeft = true;
                    // Only update the default name if no custom name
                    if (!existingStation.customName) {
                        existingStation.name = `Station L${i}`;
                    }
                    // Ensure segmentDistance exists
                    if (existingStation.segmentDistance === undefined) {
                        existingStation.segmentDistance = 10;
                    }
                }
                stations.push(existingStation);
            }
            
            // Add offtake station
            stations.push(offtakeStation);
            
            // Add right stations
            for (let i = 1; i <= numStations; i++) {
                const targetId = `station_right_${i}`;
                
                // Try to find existing station
                let existingStation = stationMap.get(targetId);
                
                if (!existingStation) {
                    // Create new station
                    existingStation = {
                        id: targetId,
                        name: `Station R${i}`,
                        customName: '',
                        segmentDistance: 10,
                        isLeft: false,
                        height: 40,
                        width: 1,
                        ntg: 0.8,
                        porosity: 0.25,
                        permeability: 100,
                        depth: 2000
                    };
                } else {
                    // Preserve existing station data
                    existingStation.isLeft = false;
                    // Only update the default name if no custom name
                    if (!existingStation.customName) {
                        existingStation.name = `Station R${i}`;
                    }
                    // Ensure segmentDistance exists
                    if (existingStation.segmentDistance === undefined) {
                        existingStation.segmentDistance = 10;
                    }
                }
                stations.push(existingStation);
            }
            
            appState.updateStations(stations);
            
            // Initialize initial pressures
            initialPressures = [];
            stations.forEach(station => {
                initialPressures.push(calculateHydrostaticPressure(station.depth));
            });
            
            // If chart exists and station count changed, reinitialize
            if (stationPressureChart && stations.length !== stationPressureChart.data.datasets.length) {
                initializeStationChart();
            }
        }
        
        function renderStations() {
            const project = appState.getCurrentProject();
            if (!project || !project.config.stations) return;
            
            const stations = project.config.stations;
            const plumbingDiagram = document.getElementById('plumbingDiagram');
            
            // Clear existing stations and pipes
            const existingElements = plumbingDiagram.querySelectorAll('.station-wrapper, .pipe, .parameter-label, .distance-label');
            existingElements.forEach(el => el.remove());
            
            // Calculate positions for stations
            const totalStations = stations.length;
            const margin = 10; // Percentage margin on each side
            const availableWidth = 100 - 2 * margin;
            
            stations.forEach((station, index) => {
                // Position based on index
                const left = margin + (index / (totalStations - 1)) * availableWidth;
                
                const stationWrapper = document.createElement('div');
                stationWrapper.className = 'station-wrapper';
                stationWrapper.style.left = `${left}%`;
                stationWrapper.style.top = '50%';
                stationWrapper.style.transform = 'translate(-50%, -50%)';
                stationWrapper.onclick = () => showStationInput(index);
                stationWrapper.onmouseenter = function() {
                    const stationIndex = index; // Capture index in closure
                    
                    // Clear any pending debounced updates
                    if (calculationUpdateTimeout) {
                        clearTimeout(calculationUpdateTimeout);
                    }
                    
                    // Update header immediately when hovering
                    if (document.getElementById('calculationInfo').classList.contains('active')) {
                        const project = appState.getCurrentProject();
                        if (project && project.config.stations && project.config.stations[stationIndex]) {
                            const debugInfo = document.getElementById('debugInfo');
                            const time = parseFloat(document.getElementById('timeSlider').value);
                            if (debugInfo) {
                                debugInfo.innerHTML = `<strong>Showing calculations for ${project.config.stations[stationIndex].name}</strong> at t = ${time.toFixed(2)} years`;
                            }
                        }
                    }
                    
                    // Update immediately on hover
                    updateDebugViewForStation(stationIndex);
                };
                
                const nameLabel = document.createElement('div');
                nameLabel.className = 'station-name';
                
                // Find the offtake station index
                const offtakeIndex = stations.findIndex(s => s.id === 'offtake');
                
                // Assign color: offtake gets red, others get colors based on side
                let colorIndex;
                if (index === offtakeIndex) {
                    colorIndex = 0; // Red for offtake
                } else if (station.isLeft) {
                    // Left stations: use colors from the end backwards
                    const leftStations = stations.filter(s => s.isLeft);
                    const positionFromOfftake = leftStations.filter(s => parseInt(s.id.match(/\d+/)[0]) <= parseInt(station.id.match(/\d+/)[0])).length;
                    // Start from the last color and work backwards
                    colorIndex = stationColors.length - ((positionFromOfftake - 1) % (stationColors.length - 1)) - 1;
                    // Ensure we don't use red (index 0)
                    if (colorIndex === 0) colorIndex = stationColors.length - 1;
                } else {
                    // Right stations: use colors from the beginning forward
                    const rightStations = stations.filter(s => !s.isLeft && s.id !== 'offtake');
                    const positionFromOfftake = rightStations.filter(s => parseInt(s.id.match(/\d+/)[0]) <= parseInt(station.id.match(/\d+/)[0])).length;
                    // Start at color index 1 (orange) and cycle through
                    colorIndex = ((positionFromOfftake - 1) % (stationColors.length - 1)) + 1;
                }
                
                nameLabel.style.color = stationColors[colorIndex];
                nameLabel.textContent = station.name;
                stationWrapper.appendChild(nameLabel);
                
                const stationDiv = document.createElement('div');
                stationDiv.className = 'station';
                stationDiv.style.backgroundColor = stationColors[colorIndex];
                
                const depletionDiv = document.createElement('div');
                depletionDiv.className = 'depletion-display';
                depletionDiv.id = `${station.id}Depletion`;
                depletionDiv.textContent = '0.0 bar';
                const depletionTooltipText = "Depletion";
                depletionDiv.onmouseenter = () => showTooltip(depletionDiv, depletionTooltipText, depletionDiv);
                depletionDiv.onmouseleave = hideTooltip;
                
                const pressureDiv = document.createElement('div');
                pressureDiv.className = 'pressure-display';
                pressureDiv.id = `${station.id}Pressure`;
                pressureDiv.textContent = '-- bar';
                
                stationDiv.appendChild(depletionDiv);
                stationDiv.appendChild(pressureDiv);
                stationWrapper.appendChild(stationDiv);
                
                plumbingDiagram.appendChild(stationWrapper);
                
                // Add pipe to next station
                if (index < totalStations - 1) {
                    const nextStation = stations[index + 1];
                    const pipeDiv = document.createElement('div');
                    pipeDiv.className = 'pipe';
                    const pipeLeft = left;
                    const nextLeft = margin + ((index + 1) / (totalStations - 1)) * availableWidth;
                    const pipeWidth = Math.abs(nextLeft - pipeLeft);
                    pipeDiv.style.left = `${Math.min(pipeLeft, nextLeft)}%`;
                    pipeDiv.style.width = `${pipeWidth}%`;
                    plumbingDiagram.appendChild(pipeDiv);
                    
                    const permLabel = document.createElement('div');
                    permLabel.className = 'parameter-label permeability';
                    permLabel.id = `perm${index}`;
                    permLabel.style.left = `${(pipeLeft + nextLeft) / 2}%`;
                    permLabel.style.transform = 'translateX(-50%)'; // Add this line
                    permLabel.textContent = '-- mD';
                    plumbingDiagram.appendChild(permLabel);
                    
                    const dimLabel = document.createElement('div');
                    dimLabel.className = 'parameter-label dimensions';
                    dimLabel.id = `dim${index}`;
                    dimLabel.style.left = `${(pipeLeft + nextLeft) / 2}%`;
                    dimLabel.style.transform = 'translateX(-50%)'; // Add this line
                    dimLabel.textContent = '--  -- m';
                    plumbingDiagram.appendChild(dimLabel);
                    
                    const distLabel = document.createElement('div');
                    distLabel.className = 'distance-label';
                    distLabel.id = `dist${index}`;
                    distLabel.style.left = `${(pipeLeft + nextLeft) / 2}%`;
                    distLabel.style.transform = 'translateX(-50%)'; // Add this line
                    distLabel.textContent = '-- km';
                    plumbingDiagram.appendChild(distLabel);
                }
            });
        }
        
        function showStationInput(index) {
            const project = appState.getCurrentProject();
            if (!project || !project.config.stations) return;
            
            const station = project.config.stations[index];
            
            // If it's the offtake station
            if (station.id === 'offtake') {
                showInlineInput('offtake');
                return;
            }
            
            showInlineInput('station', index);
        }
        
        // ===========================================
        // MODAL FUNCTIONS
        // ===========================================
        
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            if (event.target.className === 'modal') {
                event.target.style.display = 'none';
            }
        }
        
        // ===========================================
        // PRESSURE DATA FUNCTIONS (ENHANCED FOR TABLE)
        // ===========================================
        
        function calculateHydrostaticPressure(depth) {
            const project = appState.getCurrentProject();
            if (!project) return 0;
            
            const waterDensity = parseFloat(project.config.waterDensity) * 1000; // kg/m
            const overpressure = parseFloat(project.config.aquiferOverpressure || 0); // bar
            const g = 9.81; // m/s
            const pressure_pa = waterDensity * g * depth;
            const pressure_bar = pressure_pa / 1e5;
            return pressure_bar + overpressure;
        }
        
        // Load pressure data into table format
        function loadPressureTable() {
            const project = appState.getCurrentProject();
            if (!project) return;
            
            const tbody = document.getElementById('pressureTableBody');
            if (!tbody) return; // Guard against missing elements
            
            tbody.innerHTML = '';
            
            // Always add the first row (hydrostatic at t=0)
            const offtakeDepth = project.config.offtakeDepth || 2000;
            const hydrostaticPressure = calculateHydrostaticPressure(offtakeDepth);
            addPressureRowElement(0, hydrostaticPressure, true);
            
            // Add rows for existing pressure data (skip t=0)
            if (project.config.pressureData) {
                project.config.pressureData.forEach(entry => {
                    if (entry.time > 0) {
                        addPressureRowElement(entry.time, entry.pressure);
                    }
                });
            }
        }
        
        // Add a new pressure row to the table
        function addPressureRow() {
            addPressureRowElement('', '');
            updatePressureTableData();
        }
        
        // Create and add a pressure row element
        function addPressureRowElement(time = '', pressure = '', isFirst = false) {
            const tbody = document.getElementById('pressureTableBody');
            if (!tbody) return; // Guard against missing elements
            
            const row = document.createElement('tr');
            
            row.innerHTML = `
                <td><input type="number" placeholder="Time" value="${time}" step="0.1" ${isFirst ? 'disabled style="background-color: #e8f4fc;"' : ''} onchange="updatePressureTableData()"></td>
                <td><input type="number" placeholder="Pressure" value="${pressure}" step="1" ${isFirst ? 'disabled style="background-color: #e8f4fc;"' : ''} onchange="updatePressureTableData()"></td>
                <td><button class="delete-btn" onclick="deletePressureRow(this)" ${isFirst ? 'style="visibility: hidden;"' : ''}><i class="fas fa-times"></i></button></td>
            `;
            
            tbody.appendChild(row);
        }
        
        // Delete a pressure row
        function deletePressureRow(button) {
            const row = button.closest('tr');
            row.remove();
            updatePressureTableData();
        }
        
        // Update pressure data from table
        function updatePressureTableData() {
            const project = appState.getCurrentProject();
            if (!project) return;
            
            const tbody = document.getElementById('pressureTableBody');
            if (!tbody) return; // Guard against missing elements
            
            const rows = tbody.querySelectorAll('tr');
            const pressureData = [];
            
            rows.forEach((row, index) => {
                const inputs = row.querySelectorAll('input');
                const time = parseFloat(inputs[0].value);
                const pressure = parseFloat(inputs[1].value);
                
                if (!isNaN(time) && !isNaN(pressure)) {
                    pressureData.push({ time, pressure });
                }
            });
            
            pressureData.sort((a, b) => a.time - b.time);
            
            appState.updatePressureData(pressureData);
        }
        
        // Cubic spline interpolation
        function cubicSplineInterpolate(points, x) {
            if (points.length === 0) return 0;
            if (points.length === 1) return points[0].pressure;
            if (x <= points[0].time) return points[0].pressure;
            if (x >= points[points.length - 1].time) return points[points.length - 1].pressure;
            
            const n = points.length;
            const h = [];
            const alpha = [];
            const l = [];
            const mu = [];
            const z = [];
            const c = [];
            const b = [];
            const d = [];
            
            // Calculate h values
            for (let i = 0; i < n - 1; i++) {
                h[i] = points[i + 1].time - points[i].time;
            }
            
            // Calculate alpha values
            for (let i = 1; i < n - 1; i++) {
                alpha[i] = (3 / h[i]) * (points[i + 1].pressure - points[i].pressure) -
                        (3 / h[i - 1]) * (points[i].pressure - points[i - 1].pressure);
            }
            
            // Calculate l, mu, and z values
            l[0] = 1;
            mu[0] = 0;
            z[0] = 0;
            
            for (let i = 1; i < n - 1; i++) {
                l[i] = 2 * (points[i + 1].time - points[i - 1].time) - h[i - 1] * mu[i - 1];
                mu[i] = h[i] / l[i];
                z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
            }
            
            l[n - 1] = 1;
            z[n - 1] = 0;
            c[n - 1] = 0;
            
            // Calculate c, b, and d values
            for (let j = n - 2; j >= 0; j--) {
                c[j] = z[j] - mu[j] * c[j + 1];
                b[j] = (points[j + 1].pressure - points[j].pressure) / h[j] -
                    h[j] * (c[j + 1] + 2 * c[j]) / 3;
                d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
            }
            
            // Find the right interval
            let i = 0;
            for (let j = 0; j < n - 1; j++) {
                if (x >= points[j].time && x <= points[j + 1].time) {
                    i = j;
                    break;
                }
            }
            
            // Calculate the interpolated value
            const dx = x - points[i].time;
            const result = points[i].pressure + b[i] * dx + c[i] * dx * dx + d[i] * dx * dx * dx;
            
            return result;
        }
        
        // Linear interpolation
        function linearInterpolate(points, x) {
            if (points.length === 0) return 0;
            if (points.length === 1) return points[0].pressure;
            if (x <= points[0].time) return points[0].pressure;
            if (x >= points[points.length - 1].time) return points[points.length - 1].pressure;
            
            for (let i = 0; i < points.length - 1; i++) {
                if (x >= points[i].time && x <= points[i + 1].time) {
                    const t1 = points[i].time;
                    const t2 = points[i + 1].time;
                    const p1 = points[i].pressure;
                    const p2 = points[i + 1].pressure;
                    
                    const fraction = (x - t1) / (t2 - t1);
                    return p1 + fraction * (p2 - p1);
                }
            }
            
            return points[points.length - 1].pressure;
        }
        
        // Interpolate pressure at given time
        function interpolatePressure(time) {
            const project = appState.getCurrentProject();
            if (!project || !project.config.pressureData || project.config.pressureData.length === 0) {
                // If no pressure data at all, return hydrostatic pressure
                const offtakeDepth = parseFloat(project.config.offtakeDepth || 2000);
                return calculateHydrostaticPressure(offtakeDepth);
            }
            
            const useSpline = project.config.useSplineInterpolation;
            const pressureData = project.config.pressureData;
            
            if (useSpline) {
                return cubicSplineInterpolate(pressureData, time);
            } else {
                return linearInterpolate(pressureData, time);
            }
        }
        
        // Update pressure chart
        function updatePressureChart() {
            const canvas = document.getElementById('pressureChart');
            if (!canvas) return; // Guard against missing elements
            
            const ctx = canvas.getContext('2d');
            const project = appState.getCurrentProject();
            
            if (pressureChart) {
                pressureChart.destroy();
                pressureChart = null;
            }
            
            if (!project || !project.config.pressureData) return;
            
            const pressureData = project.config.pressureData;
            
            // Generate smooth curve data
            const smoothData = [];
            const maxTime = Math.max(...pressureData.map(p => p.time), 20);
            for (let t = 0; t <= maxTime; t += 0.1) {
                smoothData.push({
                    x: t,
                    y: interpolatePressure(t)
                });
            }
            
            pressureChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Pressure Data Points',
                        data: pressureData.map(p => ({x: p.time, y: p.pressure})),
                        borderColor: 'rgba(52, 152, 219, 1)',
                        backgroundColor: 'rgba(52, 152, 219, 0.2)',
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        showLine: false
                    }, {
                        label: 'Interpolated Pressure',
                        data: smoothData,
                        borderColor: 'rgba(231, 76, 60, 1)',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Offtake Pressure Schedule'
                        },
                        customCanvasBackgroundColor: {
                            color: 'white',
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (years)'
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Pressure (bar)'
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        }
                    }
                }
            });
        }
        
        // ===========================================
        // STATION PRESSURE CHART FUNCTIONS
        // ===========================================
        
        function initializeStationChart() {
            const ctx = document.getElementById('stationPressureChart').getContext('2d');
            const project = appState.getCurrentProject();
            
            if (stationPressureChart) {
                stationPressureChart.destroy();
            }
            
            if (!project || !project.config.stations) return;
            
            const stations = project.config.stations;
            
            // Find the offtake station index
            const offtakeIndex = stations.findIndex(s => s.id === 'offtake');
            
            // Create datasets for each station
            const datasets = stations.map((station, index) => {
                // Assign color: offtake gets red, others get colors based on side
                let colorIndex;
                if (index === offtakeIndex) {
                    colorIndex = 0; // Red for offtake
                } else if (station.isLeft) {
                    // Left stations: use colors from the end backwards
                    const leftStations = stations.filter(s => s.isLeft);
                    const positionFromOfftake = leftStations.filter(s => parseInt(s.id.match(/\d+/)[0]) <= parseInt(station.id.match(/\d+/)[0])).length;
                    // Start from the last color and work backwards
                    colorIndex = stationColors.length - ((positionFromOfftake - 1) % (stationColors.length - 1)) - 1;
                    // Ensure we don't use red (index 0)
                    if (colorIndex === 0) colorIndex = stationColors.length - 1;
                } else {
                    // Right stations: use colors from the beginning forward
                    const rightStations = stations.filter(s => !s.isLeft && s.id !== 'offtake');
                    const positionFromOfftake = rightStations.filter(s => parseInt(s.id.match(/\d+/)[0]) <= parseInt(station.id.match(/\d+/)[0])).length;
                    // Start at color index 1 (orange) and cycle through
                    colorIndex = ((positionFromOfftake - 1) % (stationColors.length - 1)) + 1;
                }
                
                return {
                    label: station.name,
                    data: [],
                    borderColor: stationColors[colorIndex],
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    tension: 0
                };
            });
            
            const chartTitle = appState.getAppSettings().showDepletionChart ? 
                'Station Depletion History' : 'Station Pressure History';
            const yAxisLabel = appState.getAppSettings().showDepletionChart ? 
                'Depletion (bar)' : 'Pressure (bar)';
            
            stationPressureChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: chartTitle
                        },
                        verticalLine: {
                            x: 0
                        },
                        customCanvasBackgroundColor: {
                            color: 'white',
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (years)'
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: yAxisLabel
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        }
                    }
                }
            });
            
            updatePressureHistory();
        }
        
        function updatePressureHistory() {
            const project = appState.getCurrentProject();
            if (!project || !stationPressureChart) return;
            
            const simulationLength = parseFloat(project.config.simulationLength);
            const steps = 100;
            const showDepletion = appState.getAppSettings().showDepletionChart;
            
            // Update chart title and y-axis label
            stationPressureChart.options.plugins.title.text = showDepletion ? 
                'Station Depletion History' : 'Station Pressure History';
            stationPressureChart.options.scales.y.title.text = showDepletion ? 
                'Depletion (bar)' : 'Pressure (bar)';
            
            // Clear existing data
            stationPressureChart.data.datasets.forEach(dataset => {
                dataset.data = [];
            });
            
            // Calculate segment properties once
            const segmentProperties = calculateSegmentProperties();
            
            // Generate data for each time step
            for (let i = 0; i <= steps; i++) {
                const time = (i / steps) * simulationLength;
                const pressures = calculateStepwisePressures(time, segmentProperties);
                
                // Add data point for each station
                project.config.stations.forEach((station, stationIndex) => {
                    const hydrostatic = calculateHydrostaticPressure(station.depth);
                    const value = showDepletion ? 
                        (hydrostatic - pressures[stationIndex]) : 
                        pressures[stationIndex];
                    
                    stationPressureChart.data.datasets[stationIndex].data.push({
                        x: time,
                        y: value
                    });
                });
            }
            
            // Update current time line
            const currentTime = parseFloat(document.getElementById('timeSlider').value);
            stationPressureChart.options.plugins.verticalLine.x = currentTime;
            
            stationPressureChart.update();
        }
        
        // ===========================================
        // PHYSICS CALCULATION FUNCTIONS (FIXED)
        // ===========================================
        
        function calculateSegmentProperties() {
            const project = appState.getCurrentProject();
            if (!project || !project.config.stations) return [];
            
            const stations = project.config.stations;
            const segmentProps = [];
            
            // Get ordered stations
            const orderedStations = getOrderedStations(stations);
            
            for (let i = 0; i < orderedStations.length - 1; i++) {
                const currStation = orderedStations[i];
                const nextStation = orderedStations[i + 1];
                
                // Get fluid properties
                const waterDensity = parseFloat(project.config.waterDensity) * 1000;
                const waterViscosity_cp = parseFloat(project.config.waterViscosity);
                const waterCompressibility_bar = parseFloat(project.config.waterCompressibility);
                const rockCompressibility_bar = parseFloat(project.config.rockCompressibility);
                
                // Convert units
                // IMPORTANT: Always use properties from the station FARTHER from offtake
                let k_md, height, width, ntg, porosity;
                
                if (currStation.id === 'offtake') {
                    // Current station is offtake, use next station's properties
                    k_md = nextStation.permeability;
                    height = nextStation.height;
                    width = nextStation.width;
                    ntg = nextStation.ntg;
                    porosity = nextStation.porosity;
                } else if (nextStation.id === 'offtake') {
                    // Next station is offtake, use current station's properties
                    k_md = currStation.permeability;
                    height = currStation.height;
                    width = currStation.width;
                    ntg = currStation.ntg;
                    porosity = currStation.porosity;
                } else {
                    // Neither is offtake - use the station farther from offtake
                    // Since we're going in order, nextStation is always farther from offtake
                    k_md = nextStation.permeability;
                    height = nextStation.height;
                    width = nextStation.width;
                    ntg = nextStation.ntg;
                    porosity = nextStation.porosity;
                }
                
                const k_m2 = permeabilityMdToM2(k_md);
                const waterViscosity_pas = viscosityCpToPas(waterViscosity_cp);
                const totalCompressibility_bar = rockCompressibility_bar + waterCompressibility_bar;
                const totalCompressibility_pa = compressibilityBarToPa(totalCompressibility_bar);
                
                // Convert width to meters
                const width_m = width * 1000;
                
                // Effective properties
                const effectiveHeight = height * ntg;
                const effectiveK = k_m2 * ntg;
                
                // Calculate derived properties
                const transmissibility = calculateTransmissibility(effectiveK, effectiveHeight, width_m, waterViscosity_pas);
                const storativity = calculateStorativity(porosity, effectiveHeight, totalCompressibility_pa);
                const trueDiffusivity = calculateHydraulicDiffusivity(effectiveK, porosity, waterViscosity_pas, totalCompressibility_pa);
                const hydraulicConductivity = calculateHydraulicConductivity(effectiveK, waterDensity, waterViscosity_pas);
                
                segmentProps.push({
                    k_md,
                    k_m2,
                    effectiveK,
                    height,
                    width: width_m,  // Store in meters
                    ntg,
                    porosity,
                    effectiveHeight,
                    transmissibility,
                    storativity,
                    trueDiffusivity,
                    hydraulicConductivity,
                    waterViscosity_pas,
                    totalCompressibility_pa
                });
            }
            
            return segmentProps;
        }
        
        function calculateStepwisePressures(time, segmentProperties) {
            const project = appState.getCurrentProject();
            if (!project || !project.config.stations) return [];
            
            const stations = project.config.stations;
            const pressures = new Array(stations.length);
            const t_s = time * 365.25 * 24 * 3600;
            
            // Find the offtake station
            const offtakeIndex = stations.findIndex(s => s.id === 'offtake');
            
            // Offtake pressure
            const offtakeHydrostatic = calculateHydrostaticPressure(stations[offtakeIndex].depth);
            const offtakePressure = time === 0 ? offtakeHydrostatic : interpolatePressure(time);
            pressures[offtakeIndex] = offtakePressure;
            
            // Get ordered stations
            const orderedStations = getOrderedStations(stations);
            const orderedOfftakeIndex = orderedStations.findIndex(s => s.id === 'offtake');
            
            // Calculate pressure propagating to the right
            for (let i = orderedOfftakeIndex + 1; i < orderedStations.length; i++) {
                const currStation = orderedStations[i];
                const prevStation = orderedStations[i - 1];
                const segmentIndex = i - 1;
                
                const currIndex = stations.indexOf(currStation);
                const prevIndex = stations.indexOf(prevStation);
                const props = segmentProperties[segmentIndex];
                
                // Use segment distance directly
                const distance_m = currStation.segmentDistance * 1000;
                
                // Calculate dimensionless time
                const tD = calculateDimensionlessTime(props.trueDiffusivity, t_s, distance_m);
                
                // Calculate pressure propagation factor
                const propagationFactor = calculatePressurePropagationFactor(tD);
                
                // Get previous pressure and calculate change from hydrostatic
                const prevPressure = pressures[prevIndex];
                const prevHydrostatic = calculateHydrostaticPressure(prevStation.depth);
                const pressureChange = prevPressure - prevHydrostatic;
                
                // Calculate current pressure
                const currHydrostatic = calculateHydrostaticPressure(currStation.depth);
                const currentPressure = currHydrostatic + pressureChange * propagationFactor;
                
                pressures[currIndex] = currentPressure;
            }
            
            // Calculate pressure propagating to the left
            for (let i = orderedOfftakeIndex - 1; i >= 0; i--) {
                const currStation = orderedStations[i];
                const prevStation = orderedStations[i + 1];
                const segmentIndex = i;
                
                const currIndex = stations.indexOf(currStation);
                const prevIndex = stations.indexOf(prevStation);
                const props = segmentProperties[segmentIndex];
                
                // Use segment distance directly
                const distance_m = currStation.segmentDistance * 1000;
                
                // Calculate dimensionless time
                const tD = calculateDimensionlessTime(props.trueDiffusivity, t_s, distance_m);
                
                // Calculate pressure propagation factor
                const propagationFactor = calculatePressurePropagationFactor(tD);
                
                // Get previous pressure and calculate change from hydrostatic
                const prevPressure = pressures[prevIndex];
                const prevHydrostatic = calculateHydrostaticPressure(prevStation.depth);
                const pressureChange = prevPressure - prevHydrostatic;
                
                // Calculate current pressure
                const currHydrostatic = calculateHydrostaticPressure(currStation.depth);
                const currentPressure = currHydrostatic + pressureChange * propagationFactor;
                
                pressures[currIndex] = currentPressure;
            }
            
            return pressures;
        }
        
        function formatScientific(value) {
            if (Math.abs(value) < 0.001 || Math.abs(value) > 1000) {
                return value.toExponential(3);
            }
            return value.toFixed(4);
        }
        
        // ===========================================
        // SIMULATION UPDATE FUNCTION
        // ===========================================
        
        function updateSimulation() {
            const project = appState.getCurrentProject();
            if (!project || !project.config.stations) return;
            
            const time = parseFloat(document.getElementById('timeSlider').value);
            const stations = project.config.stations;
            
            // Update time display
            const timeDisplay = document.getElementById('timeDisplay');
            timeDisplay.textContent = formatTimeDisplay(time);
            
            // Update time slider label
            updateTimeSliderLabel();
            
            // Calculate segment properties once
            const segmentProperties = calculateSegmentProperties();
            window.lastSegmentProps = segmentProperties;
            
            // Calculate pressures at all stations
            const pressures = calculateStepwisePressures(time, segmentProperties);
            
            // Update station displays
            stations.forEach((station, index) => {
                const pressure = pressures[index];
                const hydrostatic = calculateHydrostaticPressure(station.depth);
                const depletion = hydrostatic - pressure;
                
                // Update pressure display
                const pressureElement = document.getElementById(`${station.id}Pressure`);
                if (pressureElement) {
                    pressureElement.textContent = `${pressure.toFixed(1)} bar`;
                }
                
                // Update depletion display
                const depletionElement = document.getElementById(`${station.id}Depletion`);
                if (depletionElement) {
                    depletionElement.textContent = `${depletion.toFixed(1)} bar`;
                }
            });
            
            // Update parameter labels for visual segments
            for (let i = 0; i < stations.length - 1; i++) {
                const currStation = stations[i];
                const nextStation = stations[i + 1];
                
                // Determine which station's properties to display
                let props;
                if (currStation.id === 'offtake') {
                    props = nextStation;
                } else if (nextStation.id === 'offtake') {
                    props = currStation;
                } else {
                    // Use the station farther from offtake
                    props = nextStation;
                }
                
                // Update permeability label
                const permLabel = document.getElementById(`perm${i}`);
                if (permLabel) {
                    permLabel.textContent = `${props.permeability.toFixed(0)} mD`;
                }
                
                // Update dimensions label
                const dimLabel = document.getElementById(`dim${i}`);
                if (dimLabel) {
                    const effectiveHeight = props.height * props.ntg;
                    dimLabel.textContent = `${effectiveHeight.toFixed(0)}  ${props.width.toFixed(1)} km`;
                }
                
                // Update distance label - use the correct station's segmentDistance
                const distLabel = document.getElementById(`dist${i}`);
                if (distLabel) {
                    // For left stations going towards offtake, use current station's distance
                    // For right stations going away from offtake, use next station's distance
                    let distance;
                    if (currStation.isLeft && !nextStation.isLeft) {
                        // Current is left, next is offtake - use current's distance
                        distance = currStation.segmentDistance || 0;
                    } else if (!currStation.isLeft || !nextStation.isLeft) {
                        // Either current is offtake or both are right - use next's distance
                        distance = nextStation.segmentDistance || 0;
                    } else {
                        // Both are left stations - use current's distance
                        distance = currStation.segmentDistance || 0;
                    }
                    distLabel.textContent = `${distance.toFixed(1)} km`;
                }
            }
            
            // Update chart current time line
            if (stationPressureChart) {
                stationPressureChart.options.plugins.verticalLine.x = time;
                stationPressureChart.update();
            }
            
            // Update debug view if active
            if (document.getElementById('calculationInfo').classList.contains('active')) {
                // Update header immediately to show current time
                const project = appState.getCurrentProject();
                if (project && project.config.stations && project.config.stations[lastHoveredStation]) {
                    const debugInfo = document.getElementById('debugInfo');
                    if (debugInfo) {
                        debugInfo.innerHTML = `<strong>Showing calculations for ${project.config.stations[lastHoveredStation].name}</strong> at t = ${time.toFixed(2)} years <span class="updating-indicator">(updating...)</span>`;
                    }
                }
                // Debounce the detailed calculations
                updateDebugViewForStationDebounced(lastHoveredStation);
            }
            
            // Update slider track
            updateSliderTrack();
        }
        
        // ===========================================
        // INITIALIZATION
        // ===========================================
        
        window.onload = function() {
            // Initialize state manager
            appState.init();
            
            // Switch to current project
            const currentProject = appState.getCurrentProject();
            if (currentProject) {
                loadProjectToUI(currentProject);
            }
            
            // Update slider track
            updateSliderTrack();
        };
    </script>
</body>
</html>
